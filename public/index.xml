<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</title>
    <link>https://malinkang.cn/</link>
    <description>Recent content on 人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 30 Jan 2021 15:12:35 +0000</lastBuildDate><atom:link href="https://malinkang.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>文档生成工具</title>
      <link>https://malinkang.cn/post/doc-generator/</link>
      <pubDate>Sat, 30 Jan 2021 15:12:35 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/doc-generator/</guid>
      <description>MkDocs MkDocs Material for MkDocs 1 2 3 4 5 pip install mkdocs #安装 mkdocs --version #查看版本号 pip3 install mkdocs-material #安装主题 mkdocs new docs #创建 mkdocs serve 配置： 1 2 3 4 5 6 7 8 site_name: tpln theme: name: material features: - navigation.sections - navigation.tabs nav: - Home: index.md</description>
    </item>
    
    <item>
      <title>系统闹钟源码分析</title>
      <link>https://malinkang.cn/post/deskclock-analysis/</link>
      <pubDate>Tue, 19 Jan 2021 09:21:04 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/deskclock-analysis/</guid>
      <description>核心类 UI部分 DeskClock：主界面，由ViewPager实现。 DeskClockFragment：首页四个Fragment的基类。 Al</description>
    </item>
    
    <item>
      <title>绑定服务</title>
      <link>https://malinkang.cn/post/bound-services/</link>
      <pubDate>Mon, 14 Dec 2020 19:18:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/bound-services/</guid>
      <description>绑定服务是 Service 类的实现，可让其他应用与其进行绑定和交互。如要为服务提供绑定，您必须实现 onBind() 回调方法。该方法会返回 IBinder 对象，该对象定义的编程接口可供</description>
    </item>
    
    <item>
      <title>WorkManager源码分析</title>
      <link>https://malinkang.cn/post/workmanager-source-analysis/</link>
      <pubDate>Mon, 07 Dec 2020 20:40:56 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/workmanager-source-analysis/</guid>
      <description>WorkManager WorkManger是一个单例对象, 但是从例子代码中没有看的调用初始化的地方。通过文档可知 WorkManager有两种初始化方式: 应用启动</description>
    </item>
    
    <item>
      <title>ButterKnife源码分析</title>
      <link>https://malinkang.cn/post/butterknife-source-analysis/</link>
      <pubDate>Wed, 02 Dec 2020 16:37:06 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/butterknife-source-analysis/</guid>
      <description>本文分析的源码为8.4.0。 项目结构 butterknife包含ButterKnife核心的Api，如ButterKnife。butterkn</description>
    </item>
    
    <item>
      <title>RxJava源码分析</title>
      <link>https://malinkang.cn/post/rxjava-source-analysis/</link>
      <pubDate>Fri, 27 Nov 2020 23:47:34 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/rxjava-source-analysis/</guid>
      <description>RxJava创建过程 create() 调用create()创建Observable。 1 2 3 4 5 6 7 8 9 10 11 Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { @Override public void subscribe(@NonNull ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Throwable { emitter.onNext(2); } }).subscribe(new Consumer&amp;lt;Integer&amp;gt;() { @Override public void accept(Integer integer) throws Throwable {</description>
    </item>
    
    <item>
      <title>Leakcanary源码分析</title>
      <link>https://malinkang.cn/post/leakcanary-source-analysis/</link>
      <pubDate>Wed, 25 Nov 2020 20:10:28 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/leakcanary-source-analysis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Glide源码分析</title>
      <link>https://malinkang.cn/post/glide-source-analysis/</link>
      <pubDate>Wed, 25 Nov 2020 20:07:31 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/glide-source-analysis/</guid>
      <description>Glide源码分析 Glide的使用非常简单只需要调用with、load into三个方法。 1 2 3 GlideApp.with(this) .load(url) .into(imageView); 接下来，我们依次分析这三个方法。 with() 1 2 3</description>
    </item>
    
    <item>
      <title>Okio源码分析</title>
      <link>https://malinkang.cn/post/okio-source-analysis/</link>
      <pubDate>Wed, 25 Nov 2020 20:07:14 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/okio-source-analysis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Okhttp源码分析</title>
      <link>https://malinkang.cn/post/okhttp-source-analysis/</link>
      <pubDate>Wed, 25 Nov 2020 20:01:47 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/okhttp-source-analysis/</guid>
      <description>Okhttp基本流程分析 基本流程 创建RequestBody 创建Request 创建OkhttpClient 调用newCall创建Call对象 执</description>
    </item>
    
    <item>
      <title>ARouter源码分析</title>
      <link>https://malinkang.cn/post/arouter-source-analysis/</link>
      <pubDate>Tue, 24 Nov 2020 11:14:29 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/arouter-source-analysis/</guid>
      <description>ARouter原理如下 编译期，会扫描@Route注解，将注解里的信息封装成一个RouteMeta对象。并生成一个辅助类ARouter$$Gr</description>
    </item>
    
    <item>
      <title>Recyclerview源码分析三</title>
      <link>https://malinkang.cn/post/recyclerview-analysis-3/</link>
      <pubDate>Fri, 04 Sep 2020 16:39:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/recyclerview-analysis-3/</guid>
      <description>上一篇分析RecyclerView整体流程的时候提到，RecyclerView缓存机制比较复杂，所以这一篇单独分析一下RecyclerVie</description>
    </item>
    
    <item>
      <title>Recyclerview源码分析二</title>
      <link>https://malinkang.cn/post/recyclerview-analysis-2/</link>
      <pubDate>Thu, 03 Sep 2020 16:39:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/recyclerview-analysis-2/</guid>
      <description>&lt;p&gt;在上一篇文章中，我们主要分析了&lt;code&gt;RecyclerView&lt;/code&gt;中的几个重要的内部类。今天我们就把它们串起来，看它们分别是如何工作的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Recyclerview源码分析一</title>
      <link>https://malinkang.cn/post/recyclerview-analysis-1/</link>
      <pubDate>Wed, 02 Sep 2020 16:39:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/recyclerview-analysis-1/</guid>
      <description>&lt;p&gt;&lt;code&gt;RecyclerView&lt;/code&gt;是我们开发中最常用的控件，&lt;code&gt;RecyclerView&lt;/code&gt;是如何工作的，如何处理缓存的有助于解决一些使用&lt;code&gt;RecyclerView&lt;/code&gt;的bug和优化&lt;code&gt;RecyclerView&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>什么是响应式编程</title>
      <link>https://malinkang.cn/post/what-is-reactive-programming/</link>
      <pubDate>Tue, 28 Jul 2020 10:44:19 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/what-is-reactive-programming/</guid>
      <description>&lt;p&gt;最近被人问起什么是响应式编程，虽然使用&lt;code&gt;RxJava&lt;/code&gt;已经五六年了，但真正让我用一句话来概括什么是响应式编程还真有点困难。打开google，搜索什么是函数编程，看了几遍文章也没有明确的答案，这里谈谈自己的理解。&lt;/p&gt;
&lt;p&gt;响应式编程一个核心的概念是流（stream）。可以基于任何东西创建数据流。流非常轻便，并且无处不在，任何东西都可以是一个流：变量，用户输入，属性，缓存，数据结构等等。除此之外，我们有很多功能强大的函数，可以对这些流进行合并、过滤、转变等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>wms</title>
      <link>https://malinkang.cn/post/framework-wms/</link>
      <pubDate>Mon, 16 Mar 2020 15:16:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-wms/</guid>
      <description>Window WindowManagerService 1 2 3 4 5 6 7 8 9 //frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java public static WindowManagerService main(final Context context, final InputManagerService im, final boolean haveInputMethods, final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy) { DisplayThread.getHandler().runWithScissors(() -&amp;gt; sInstance = new WindowManagerService(context, im, haveInputMethods, showBootMsgs, onlyCore, policy), 0); return sInstance; } 1 2 3 4 5 6 7 8 //frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) { if (client == null)</description>
    </item>
    
    <item>
      <title>startActivity流程分析</title>
      <link>https://malinkang.cn/post/start-activity/</link>
      <pubDate>Thu, 27 Feb 2020 16:07:48 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/start-activity/</guid>
      <description>&lt;p&gt;Activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根Activity指的是应用程序启动的第一个Activity，因此根Activity的启动过程一般情况下也可以理解为应用程序的启动过程。普通Activity指的是除应用程序启动的第一个Activity之外的其他Activity。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>创建应用程序进程</title>
      <link>https://malinkang.cn/post/create-application-process/</link>
      <pubDate>Thu, 27 Feb 2020 09:55:01 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/create-application-process/</guid>
      <description>&lt;p&gt;一个App打开另一个App的Activity或者绑定另外一个App的服务的过程，如果另外一个App的进程不存在，都会先创建另外一个App的进程，再执行后续操作。&lt;/p&gt;
&lt;p&gt;应用程序进程创建过程可以分为以下几部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AMS发送启动应用程序进程请求&lt;/li&gt;
&lt;li&gt;Zygote接收请求并创建应用程序进程。&lt;/li&gt;
&lt;li&gt;ActivityThread初始化&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>setContentView发生了什么</title>
      <link>https://malinkang.cn/post/framework-setcontentview/</link>
      <pubDate>Sun, 23 Feb 2020 17:19:13 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-setcontentview/</guid>
      <description>1 2 3 frameworks/base/core/java/android/view/ViewManager.java frameworks/base/core/java/android/view/WindowManager.java frameworks/base/core/java/android/view/WindowManagerImpl.java 流程图 创建Window和WindowManager的过程 {% plantuml %} &amp;ndash;&amp;gt;Activity:attach() Activity&amp;ndash;&amp;gt;Window: 创建Window Activity&amp;ndash;&amp;gt;ContextImpl: getSystemService ContextImpl&amp;ndash;&amp;gt;SystemServiceRegistry: getSystemService SystemServiceRegistry&amp;ndash;&amp;gt; Activity: 返回WindowManagerIm</description>
    </item>
    
    <item>
      <title>AMS分析</title>
      <link>https://malinkang.cn/post/framework-ams/</link>
      <pubDate>Sat, 22 Feb 2020 14:48:10 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-ams/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /*</description>
    </item>
    
    <item>
      <title>Parcel源码分析</title>
      <link>https://malinkang.cn/post/framework-parcel/</link>
      <pubDate>Thu, 20 Feb 2020 15:11:27 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-parcel/</guid>
      <description></description>
    </item>
    
    <item>
      <title>添加和获取服务</title>
      <link>https://malinkang.cn/post/framework-add-and-get-service/</link>
      <pubDate>Sat, 15 Feb 2020 17:03:15 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-add-and-get-service/</guid>
      <description></description>
    </item>
    
    <item>
      <title>获取ServiceManager</title>
      <link>https://malinkang.cn/post/framework-get-sm/</link>
      <pubDate>Sat, 08 Feb 2020 09:44:44 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-get-sm/</guid>
      <description>&lt;p&gt;&lt;code&gt;ServiceManager&lt;/code&gt;的&lt;code&gt;addService&lt;/code&gt;和&lt;code&gt;getService&lt;/code&gt;方法都会首先调用&lt;code&gt;getIServiceManager&lt;/code&gt;来获取&lt;code&gt;ServiceManager&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>启动ServiceManager</title>
      <link>https://malinkang.cn/post/framework-start-sm/</link>
      <pubDate>Sat, 01 Feb 2020 22:07:20 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-start-sm/</guid>
      <description>&lt;p&gt;&lt;code&gt;ServiceManager&lt;/code&gt;在&lt;code&gt;init.rc&lt;/code&gt;中启动的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//system/core/rootdir/init.rc
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;servicemanager&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;servicemanager&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;core&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;group&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;critical&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;onrestart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;healthd&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;onrestart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zygote&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;onrestart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;media&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;onrestart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;surfaceflinger&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;onrestart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;restart&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Binder驱动分析</title>
      <link>https://malinkang.cn/post/framework-binder-driver/</link>
      <pubDate>Sat, 25 Jan 2020 09:44:44 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-binder-driver/</guid>
      <description>参考 理解Android Binder机制(1/3)：驱动篇</description>
    </item>
    
    <item>
      <title>SystemServer启动流程</title>
      <link>https://malinkang.cn/post/framework-systemserver/</link>
      <pubDate>Sat, 18 Jan 2020 14:04:10 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-systemserver/</guid>
      <description>&lt;p&gt;&lt;code&gt;SystemServer&lt;/code&gt;进程主要用于创建系统服务，我们熟知的AMS、WMS和PMS都是由它来创建的。&lt;/p&gt;
&lt;p&gt;一旦在&lt;code&gt;init.rc&lt;/code&gt;中为&lt;code&gt;Zygote&lt;/code&gt;制定了启动参数&lt;code&gt;--start-system-server&lt;/code&gt;，那么&lt;code&gt;ZygoteInit&lt;/code&gt;就会调用&lt;code&gt;startSystemServer&lt;/code&gt;来启动&lt;code&gt;SystemServer&lt;/code&gt;集成。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zygote进程启动流程</title>
      <link>https://malinkang.cn/post/framework-zygote/</link>
      <pubDate>Sat, 11 Jan 2020 15:01:48 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-zygote/</guid>
      <description>&lt;p&gt;在Android系统中，应用程序进程以及运行系统的关键服务的&lt;code&gt;SystemServer&lt;/code&gt;进程都是由&lt;code&gt;Zygote&lt;/code&gt;进程来创建的，我们也将它称为孵化器。它通过&lt;code&gt;fork&lt;/code&gt;（复制进程）的形式来创建应用程序进程和&lt;code&gt;SystemServer&lt;/code&gt;进程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Epoxy Models</title>
      <link>https://malinkang.cn/post/epoxy-models/</link>
      <pubDate>Sun, 05 Jan 2020 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/epoxy-models/</guid>
      <description>概览（Overview） Epoxy uses EpoxyModel objects to decide which views to display and how to bind data to them. This is similar to the popular ViewModel pattern. Models also allow you to control other aspects of the view, such as the grid span size, id, and saved state. Epoxy使用Epoxy</description>
    </item>
    
    <item>
      <title>init启动流程分析</title>
      <link>https://malinkang.cn/post/framework-init/</link>
      <pubDate>Sat, 04 Jan 2020 15:01:48 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-init/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Improve App Performance With Kotlin Coroutines</title>
      <link>https://malinkang.cn/post/improve-app-performance-with-kotlin-coroutines/</link>
      <pubDate>Tue, 15 Oct 2019 19:02:36 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/improve-app-performance-with-kotlin-coroutines/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.android.com/kotlin/coroutines&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协程是一种并发设计模式，您可以在&lt;code&gt;Android&lt;/code&gt;上使用它来简化异步执行的代码。 &lt;code&gt;Coroutines&lt;/code&gt;在版本1.3中添加到&lt;code&gt;Kotlin&lt;/code&gt;，并基于其他语言的既定概念。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Android&lt;/code&gt;上，协同程序有助于解决两个主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理长时间运行的任务，否则可能会阻止主线程并导致应用冻结。&lt;/li&gt;
&lt;li&gt;提供主安全性，或从主线程安全地调用网络或磁盘操作。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Dex文件格式分析</title>
      <link>https://malinkang.cn/post/dex-file-format/</link>
      <pubDate>Fri, 27 Sep 2019 10:04:55 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/dex-file-format/</guid>
      <description>&lt;p&gt;在刚学习Java的时候我们都会写一个&lt;code&gt;HelloWorld&lt;/code&gt;的示例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HelloWorld&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello,world!&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后通过&lt;code&gt;javac&lt;/code&gt;命令编译成字节码，然后调用&lt;code&gt;java&lt;/code&gt;命令机执行字节码。我们如何像&lt;code&gt;java&lt;/code&gt;一样在命令行里直接在命令行输出&lt;code&gt;Hello,world!&lt;/code&gt;呢。具体要执行如下操作：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Activity的启动流程</title>
      <link>https://malinkang.cn/post/android-activity-launch-process/</link>
      <pubDate>Tue, 24 Sep 2019 15:53:26 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-activity-launch-process/</guid>
      <description>&lt;p&gt;App启动的整体流程分为以下7个阶段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Launcher&lt;/code&gt;通知AMS，要启动&lt;code&gt;App&lt;/code&gt;，而且指定要启动&lt;code&gt;App&lt;/code&gt;的哪个页面（也就是首页）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AMS&lt;/code&gt;通知Launcher, “好了我知道了，没你什么事了”。同时，把要启动的首页记下来。&lt;/li&gt;
&lt;li&gt;Launcher当前页面进入Paused状态，然后通知AMS, “我睡了，你可以去找App了”。&lt;/li&gt;
&lt;li&gt;AMS检查App是否已经启动了。是，则唤起App即可。否，就要启动一个新的进程。AMS在新进程中创建一个ActivityThread对象，启动其中的main函数。&lt;/li&gt;
&lt;li&gt;App启动后，通知AMS, “我启动好了”。&lt;/li&gt;
&lt;li&gt;AMS翻出之前在2中存的值，告诉App，启动哪个页面。&lt;/li&gt;
&lt;li&gt;App启动首页，创建Context并与首页Activity关联。然后调用首页&lt;code&gt;Activity&lt;/code&gt;的onCreate函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此启动流程完成，可分成两部分：第1～3阶段，Launcher和AMS相互通信；第4～7阶段，App和AMS相互通信。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【译】避免Android中内存泄漏的9种方法</title>
      <link>https://malinkang.cn/post/9-ways-to-avoid-memory-leaks-in-android/</link>
      <pubDate>Mon, 10 Jun 2019 14:33:57 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/9-ways-to-avoid-memory-leaks-in-android/</guid>
      <description>原文，本文介绍了，引发内存泄露的常见情况，并给出了对应的修复方法。 I have been an android developer for quite some time now. And I realised（意识到） that most of that time, I tend to spend on adding</description>
    </item>
    
    <item>
      <title>Handler的使用和原理分析</title>
      <link>https://malinkang.cn/post/android-handler/</link>
      <pubDate>Fri, 26 Apr 2019 11:22:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-handler/</guid>
      <description>使用Handler 每个应用程序都有自己的特殊线程来运行UI对象，例如View对象;这个线程称为UI线程。在Android中，不允许非UI线程</description>
    </item>
    
    <item>
      <title>第2章 极限与连续性</title>
      <link>https://malinkang.cn/thomas-calculus/thomas-calculus-chapter2/</link>
      <pubDate>Tue, 16 Apr 2019 16:22:46 +0800</pubDate>
      
      <guid>https://malinkang.cn/thomas-calculus/thomas-calculus-chapter2/</guid>
      <description>2.2.2 极限法则 **定理1（极限法则）**若$L, M, c$和$k$是实数，并且 $$ \lim _{x \rightarrow c} f(x)=L, \lim _{x \rightarrow c} g(x)=M $$ 则有 （1）和法则 $$ \lim _{x \rightarrow c}(f(x)+g(x))=L+M $$ 两个函数之和的极限</description>
    </item>
    
    <item>
      <title>Column和Row详解</title>
      <link>https://malinkang.cn/post/flutter-widget-column/</link>
      <pubDate>Tue, 19 Mar 2019 14:21:37 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/flutter-widget-column/</guid>
      <description>MainAxisAlignment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69</description>
    </item>
    
    <item>
      <title>Android Build</title>
      <link>https://malinkang.cn/post/android-build/</link>
      <pubDate>Thu, 14 Mar 2019 15:18:46 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-build/</guid>
      <description>D8 Android Studio 3.0 推出了d8，并在3.1正式成为默认工具。它的作用是将“.class”文件编译为Dex文件，取代之前的dx工具。 R8 R8 在 Android Studio 3.1 中引入，志</description>
    </item>
    
    <item>
      <title>Android动态化</title>
      <link>https://malinkang.cn/post/android-dynamic/</link>
      <pubDate>Thu, 14 Mar 2019 15:18:46 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-dynamic/</guid>
      <description>移动互联网已经发展十年了，随着业务成熟和功能的相对稳定，整体重心开始偏向运营，强烈的运营需求对客户端架构和发布模式都提出了更高的要求。如果每</description>
    </item>
    
    <item>
      <title>Android网络优化</title>
      <link>https://malinkang.cn/post/android-network-performance/</link>
      <pubDate>Fri, 08 Mar 2019 09:54:39 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-network-performance/</guid>
      <description>在讲怎么去优化网络之前，我想先明确一下所谓的网络优化，究竟指的是什么？在我看来，核心内容有以下三个： 速度。在网络正常或者良好的时候，怎样更好</description>
    </item>
    
    <item>
      <title>Android优化之WebView优化</title>
      <link>https://malinkang.cn/post/android-webview-performance/</link>
      <pubDate>Thu, 07 Mar 2019 10:02:53 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-webview-performance/</guid>
      <description>百度APP-Android H5首屏优化实践</description>
    </item>
    
    <item>
      <title>Android电池优化</title>
      <link>https://malinkang.cn/post/android-battery-performance/</link>
      <pubDate>Thu, 07 Mar 2019 10:02:53 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-battery-performance/</guid>
      <description>耗电的背景知识 1.电池技术 手机电池的一些关键指标： 电池容量 充电时间 寿命 安全性 2.电量和硬件 3.电量和应用程序 Android耗电的演进历程 1.</description>
    </item>
    
    <item>
      <title>Android优化之安装包大小优化</title>
      <link>https://malinkang.cn/post/android-reduce-apk-size/</link>
      <pubDate>Tue, 05 Mar 2019 16:00:24 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-reduce-apk-size/</guid>
      <description>1.为什么要优化包体积 下载转化率 推广成本 应用市场 2.包体积与应用性能 包体积除了转化率的影响，它对我们应用性能还有哪些影响呢？ 安装时间。文件拷</description>
    </item>
    
    <item>
      <title>Android启动优化</title>
      <link>https://malinkang.cn/post/android-start-performance/</link>
      <pubDate>Tue, 05 Mar 2019 15:57:23 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-start-performance/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Android优化之内存优化</title>
      <link>https://malinkang.cn/post/android-memory-performance/</link>
      <pubDate>Tue, 05 Mar 2019 15:10:02 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-memory-performance/</guid>
      <description>目录 使用内存效率更高的代码结构 谨慎使用服务 使用经过优化的数据容器 谨慎对待代码抽象 针对序列化数据使用精简版-protobuf 避免内存抖动 移除会</description>
    </item>
    
    <item>
      <title>Android崩溃优化</title>
      <link>https://malinkang.cn/post/android-crash-performance/</link>
      <pubDate>Tue, 05 Mar 2019 10:08:28 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-crash-performance/</guid>
      <description>Android的两种崩溃 Android崩溃分为Java崩溃和Native崩溃。Java崩溃就是在Java代码中，出现了未捕获异常，导致程序异</description>
    </item>
    
    <item>
      <title>Container详解</title>
      <link>https://malinkang.cn/post/flutter-widget-container/</link>
      <pubDate>Tue, 19 Feb 2019 14:21:37 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/flutter-widget-container/</guid>
      <description>Container是一个拥有绘制、定位、调整大小的widget。 padding和margin padding和margin分别设置Contai</description>
    </item>
    
    <item>
      <title>关于自我提升的思考</title>
      <link>https://malinkang.cn/post/up/</link>
      <pubDate>Sat, 05 Jan 2019 09:54:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/up/</guid>
      <description>从12年算起，自己也在软件开发这个行业已经近7年。自己也一直在从事Android移动开发。回顾自己的这7年，对自己是非常失望的。自己一直从事</description>
    </item>
    
    <item>
      <title>Android运行时权限</title>
      <link>https://malinkang.cn/post/runtime-permissions/</link>
      <pubDate>Mon, 24 Dec 2018 20:25:35 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/runtime-permissions/</guid>
      <description>权限的作用是保护 Android 用户的隐私。Android 应用必须请求权限才能访问敏感的用户数据（例如联系人和短信）以及某些系统功能（例如相机和互联网）。</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第8章 Lambda作为形参和返回值</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter8/</link>
      <pubDate>Wed, 12 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter8/</guid>
      <description>8.1 声明高阶函数 高阶函数就是以另一个函数作为参数或者返回值的函数。 8.1.1 函数类型 1 2 3 4 5 6 7 8 val sum = { x: Int, y: Int -&amp;gt; x + y } val action = { println(42)} run { println(sum(1,2)) //3 } run{ action()</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第7章 运算符重载及其他约定</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter7/</link>
      <pubDate>Sun, 09 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter7/</guid>
      <description>7.1 重载算术运算符 7.1.1 重载二元算术运算 1 2 3 4 5 6 7 8 data class Point(val x: Int, val y: Int) { operator fun plus(other: Point): Point { return Point(x + other.x, y + other.y) } } val p1 = Point(10, 20) val p2 = Point(30, 40) println(p1 + p2) //Point(x=40, y=60) 1 2 3 operator fun Point.plus(other:</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第6章 Kotlin的类型系统</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter6/</link>
      <pubDate>Thu, 06 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter6/</guid>
      <description>6.1 可空性 6.1.1 可空类型 1 2 //增加了null检查后，这段代码就可以编译了 fun strLenSafe(s: String?) = if (s != null) s.length else 0 6.1.2 类型的含义 6.1.3 安全调用运算符 安全调用运算符?允许把</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第5章 Lambda编程</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter5/</link>
      <pubDate>Tue, 04 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter5/</guid>
      <description>5.1 Lambda表达式和成员引用 5.1.1 Lambda简介：作为函数参数的代码块 1 2 3 4 5 6 button.setOnClickLisener(new OnClickListener(){ @Override public void onClick(View view){ //点击后执行的动作 } } 1 button.se</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第4章 类对象和接口</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter4/</link>
      <pubDate>Tue, 28 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter4/</guid>
      <description>4.1 定义类继承结构 4.1.1 Kotlin中的接口 1 2 3 4 5 6 7 8 //接口定义 interface Clickable { fun click() } //实现接口 class Button:Clickable{ override fun click() = println(&amp;#34;I was clicked&amp;#34;) } 接口的方法可以有一个默认实现。</description>
    </item>
    
    <item>
      <title>kotlin基础</title>
      <link>https://malinkang.cn/post/kotlin-basic/</link>
      <pubDate>Sat, 25 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-basic/</guid>
      <description>2.1 基础要素：函数和变量 2.1.1 Hello,world! 1 2 3 fun main(args: Array&amp;lt;String&amp;gt;) { println(&amp;#34;Hello, world!&amp;#34;) } 2.1.2 函数 1 2 3 4 5 6 7 fun main(args: Array&amp;lt;String&amp;gt;) { println(max(1,2)) } fun max(a:Int,b:Int):Int{ return if(a&amp;gt;b) a else b } 表达式函数体 函数体由单个表达式构成的，可以用这</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第3章 函数的定义与调用</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter3/</link>
      <pubDate>Sat, 25 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter3/</guid>
      <description>3.1 在kotlin中创建集合 1 2 3 4 5 6 7 val set = hashSetOf(1, 7, 53) val list = arrayListOf(1, 7, 53) val map = hashMapOf(1 to &amp;#34;one&amp;#34;, 7 to &amp;#34;seven&amp;#34;, 53 to &amp;#34;fifty-three&amp;#34;) //kotlin的javaClass等价于Java的</description>
    </item>
    
    <item>
      <title>Paging 库概述</title>
      <link>https://malinkang.cn/post/paging-library-overview/</link>
      <pubDate>Fri, 27 Jul 2018 14:44:49 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/paging-library-overview/</guid>
      <description>&lt;p&gt;分页库可帮助您一次加载和显示小块数据。按需加载部分数据可减少网络带宽和系统资源的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin作用域函数</title>
      <link>https://malinkang.cn/post/kotlin-scope-functions/</link>
      <pubDate>Fri, 27 Jul 2018 15:05:51 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-scope-functions/</guid>
      <description>&lt;p&gt;&lt;code&gt;Kotlin&lt;/code&gt;标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。当对一个对象调用这样的函数并提供一个&lt;code&gt;lambda&lt;/code&gt;表达式时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。共有以下五种：&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;、&lt;code&gt;with&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt; 以及&lt;code&gt;also&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些函数基本上做了同样的事情：在一个对象上执行一个代码块。不同的是这个对象在块中如何使用，以及整个表达式的结果是什么。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin函数</title>
      <link>https://malinkang.cn/post/kotlin-functions/</link>
      <pubDate>Fri, 27 Jul 2018 15:05:51 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-functions/</guid>
      <description>函数声明 Kotlin中的函数使用fun关键字声明： 1 2 3 fun double(x: Int): Int { return 2 * x } 函数调用 调用函数使用传统的方法： 1 val result = double(2) 调用成员函数使用点表示</description>
    </item>
    
    <item>
      <title>Dagger2在Android中的使用</title>
      <link>https://malinkang.cn/post/dagger-android/</link>
      <pubDate>Wed, 25 Jul 2018 11:56:12 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/dagger-android/</guid>
      <description>&lt;p&gt;与其他大多数依赖注入框架相比，&lt;code&gt;Dagger2&lt;/code&gt;的主要优点之一是其严格生成的实现（无反射）意味着它可以在&lt;code&gt;Android&lt;/code&gt;应用程序中使用。但是，在&lt;code&gt;Android&lt;/code&gt;应用程序中使用&lt;code&gt;Dagger&lt;/code&gt;时仍有一些注意事项。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>实现navigation</title>
      <link>https://malinkang.cn/post/navigation-implementing/</link>
      <pubDate>Thu, 07 Jun 2018 16:13:46 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/navigation-implementing/</guid>
      <description>&lt;p&gt;导航体系结构组件简化了应用程序中目标之间导航的实现。目的地是应用中的特定屏幕。默认情况下，导航体系结构组件包括支持&lt;code&gt;fragment&lt;/code&gt;和&lt;code&gt;activity&lt;/code&gt;作为目标，但您也可以添加对新类型目标的支持。一组目的地组成一个应用程序的“导航图”。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LiveData概述</title>
      <link>https://malinkang.cn/post/livedata-overview/</link>
      <pubDate>Fri, 18 May 2018 16:47:47 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/livedata-overview/</guid>
      <description>&lt;p&gt;&lt;code&gt;LiveData&lt;/code&gt;是一个可观察的数据持有者类。与常规可观察性不同，&lt;code&gt;LiveData&lt;/code&gt;具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如&lt;code&gt;activity&lt;/code&gt;，&lt;code&gt;fragment&lt;/code&gt;或&lt;code&gt;service&lt;/code&gt;）的生命周期。 这确保&lt;code&gt;LiveData&lt;/code&gt;只更新处于活动生命周期状态的应用程序组件观察者。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>生成绑定类</title>
      <link>https://malinkang.cn/post/generated-binding-classes/</link>
      <pubDate>Mon, 19 Jun 2017 20:01:58 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/generated-binding-classes/</guid>
      <description>&lt;p&gt;数据绑定库生成用于访问布局的变量和视图的绑定类。生成的绑定类将布局变量与布局中的视图链接起来。绑定类的名称和包可以自定义。所有生成的绑定类都继承自&lt;code&gt;ViewDataBinding&lt;/code&gt;类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>绑定适配器使用</title>
      <link>https://malinkang.cn/post/binding-adapters/</link>
      <pubDate>Tue, 13 Jun 2017 18:14:02 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/binding-adapters/</guid>
      <description>&lt;p&gt;绑定适配器负责对设置值进行适当的框架调用。一个例子是设置一个属性值，如调用&lt;code&gt;setText()&lt;/code&gt;方法。另一个例子是设置一个事件监听器，如调用&lt;code&gt;setOnClickListener()&lt;/code&gt;方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DataBinding绑定表达式使用</title>
      <link>https://malinkang.cn/post/binding-expressions/</link>
      <pubDate>Sun, 11 Jun 2017 18:14:02 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/binding-expressions/</guid>
      <description>&lt;p&gt;表达式语言允许您编写处理&lt;code&gt;View&lt;/code&gt;分发的事件的表达式。数据绑定库自动生成将布局中的&lt;code&gt;View&lt;/code&gt;与数据对象绑定所需的类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android自定义属性</title>
      <link>https://malinkang.cn/post/android-custom-attribute/</link>
      <pubDate>Tue, 21 Mar 2017 17:37:26 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-custom-attribute/</guid>
      <description>&lt;p&gt;创建自定义属性需要以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个自定义View。&lt;/li&gt;
&lt;li&gt;创建values/attrs.xml文件，并定义属性。&lt;/li&gt;
&lt;li&gt;在View中获取属性值并使用。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Git使用</title>
      <link>https://malinkang.cn/post/git-usage/</link>
      <pubDate>Fri, 25 Nov 2016 11:22:54 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/git-usage/</guid>
      <description>git remote 1 2 3 git remote add origin git@gitee.com:malinkang/learngit.git #添加远程仓库 git remote remove origin #删除远程仓库 git remote -v #查看远程仓库地址 分支 1 2 3 4 5 6 7 git checkout -b v2.0.0 #创建分支 git checkout v1.0.0 #切换分支 git merge v1.0.0 #</description>
    </item>
    
    <item>
      <title>《深入理解JVM》第13章线程安全和锁优化</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-thread-safe-and-lock-optimization/</link>
      <pubDate>Sat, 17 Sep 2016 09:09:28 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-thread-safe-and-lock-optimization/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《深入理解Java虚拟机》第12章内存模型与线程</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-java-memory-model-and-thread/</link>
      <pubDate>Sat, 10 Sep 2016 09:09:28 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-java-memory-model-and-thread/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《深入理解JVM》第10章编译期优化</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-compilation-optimization/</link>
      <pubDate>Sat, 03 Sep 2016 09:09:28 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-compilation-optimization/</guid>
      <description>第10章 Java内存区域与内存溢出 10.1 概述 10.2 Javac编译器 10.2.1 Javac的源码与调试 从Sun Javac的代码来看，编译过程大致可以分为3个过程</description>
    </item>
    
    <item>
      <title>《深入理解JVM》第7章类加载器</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-class-loader/</link>
      <pubDate>Sat, 27 Aug 2016 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-class-loader/</guid>
      <description>&lt;p&gt;一个完整的 Java 程序是由多个 .class 文件组成的，在程序运行过程中，需要将这些 .class 文件加载到 JVM 中才可以使用。而负责加载这些 .class 文件的就是类加载器（ClassLoader）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《深入理解JVM》第6章类文件结构</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-class-file-structure/</link>
      <pubDate>Sat, 20 Aug 2016 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-class-file-structure/</guid>
      <description>&lt;p&gt;Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《深入理解JVM》第3章垃圾收集器</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-garbage-collection/</link>
      <pubDate>Sat, 13 Aug 2016 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-garbage-collection/</guid>
      <description>&lt;p&gt;垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《深入理解JVM》第2章Java运行时数据区</title>
      <link>https://malinkang.cn/post/understanding-the-jvm-runtime-data-areas/</link>
      <pubDate>Sat, 06 Aug 2016 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/understanding-the-jvm-runtime-data-areas/</guid>
      <description>&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dagger使用指南</title>
      <link>https://malinkang.cn/post/dagger-guide/</link>
      <pubDate>Mon, 25 Jul 2016 09:47:31 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/dagger-guide/</guid>
      <description>&lt;p&gt;任何应用程序中最好的类是那些做事情的类：&lt;code&gt;BarcodeDecoder&lt;/code&gt;，&lt;code&gt;KoopaPhysicsEngine&lt;/code&gt;和&lt;code&gt;AudioStreamer&lt;/code&gt;。 这些类具有依赖性; 也许是一个&lt;code&gt;BarcodeCameraFinder&lt;/code&gt;，&lt;code&gt;DefaultPhysicsEngine&lt;/code&gt;和一个&lt;code&gt;HttpStreamer&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java线程池</title>
      <link>https://malinkang.cn/post/java-threadpool/</link>
      <pubDate>Fri, 15 Jul 2016 10:24:54 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-threadpool/</guid>
      <description>线程池介绍 合理利用线程池能够带来三个好处： 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任</description>
    </item>
    
    <item>
      <title>Android Bitmap使用</title>
      <link>https://malinkang.cn/post/android-bitmap/</link>
      <pubDate>Fri, 24 Jun 2016 13:52:35 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-bitmap/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;bitmap占用内存计算&#34;&gt;Bitmap占用内存计算&lt;/h3&gt;
&lt;p&gt;Android的Bitmap对象提供了方法&lt;code&gt;getByteCount&lt;/code&gt;来获取Bitmap的字节数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getByteCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// int result permits bitmaps up to 46,340 x 46,340
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getRowBytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getHeight&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;getRowBytes()&lt;/code&gt;方法用来获取每行的字节数，内部调用一个native方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>创建 Android Studio Template</title>
      <link>https://malinkang.cn/post/android-studio-template/</link>
      <pubDate>Wed, 15 Jun 2016 10:40:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-studio-template/</guid>
      <description>&lt;p&gt;AndroidStudio 为我们提供了很多创建Activity以及其他类和文件夹的Template。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://malinkang.cn/images/android-studio-template-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Effective Java》第12章序列化</title>
      <link>https://malinkang.cn/post/effective-java-serialization/</link>
      <pubDate>Sat, 12 Mar 2016 09:02:08 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-serialization/</guid>
      <description>对象序列化（object serialization）API，提供了一个框架，用来将对象编码成字节流，并从字节流编码中重新构建对象。“将一个对</description>
    </item>
    
    <item>
      <title>《Effective Java》第11章并发</title>
      <link>https://malinkang.cn/post/effective-java-concurrency/</link>
      <pubDate>Sat, 05 Mar 2016 09:02:08 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-concurrency/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Effective Java》第10章异常</title>
      <link>https://malinkang.cn/post/effective-java-exceptions/</link>
      <pubDate>Sat, 27 Feb 2016 09:02:08 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-exceptions/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Effective Java》第9章通用程序设计</title>
      <link>https://malinkang.cn/post/effective-java-general-programming/</link>
      <pubDate>Sat, 20 Feb 2016 09:02:08 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-general-programming/</guid>
      <description>第45条：将局部变量的作用域最小化 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。 循环中提供了特殊的机会来将变量的作用</description>
    </item>
    
    <item>
      <title>《Effective Java》第8章方法</title>
      <link>https://malinkang.cn/post/effective-java-methods/</link>
      <pubDate>Sat, 13 Feb 2016 09:02:08 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-methods/</guid>
      <description>第38条：检查参数的有效性 对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值会抛出的异常。一旦在文档中记录了对于方</description>
    </item>
    
    <item>
      <title>《Effective Java》第7章lambda表达式和流</title>
      <link>https://malinkang.cn/post/effective-java-lambdas-and-streams/</link>
      <pubDate>Sat, 06 Feb 2016 09:02:08 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-lambdas-and-streams/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Effective Java》第6章枚举和注解</title>
      <link>https://malinkang.cn/post/effective-java-enums-and-annotations/</link>
      <pubDate>Sat, 30 Jan 2016 17:35:20 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-enums-and-annotations/</guid>
      <description>第30条：用enum代替int常量 在编程语言中还没有引入枚举类型之前，表示枚举类型的常量模式是声明一组具名的int常量，每个类型成员一个常量</description>
    </item>
    
    <item>
      <title>《Effective Java》第5章泛型</title>
      <link>https://malinkang.cn/post/effective-java-generics/</link>
      <pubDate>Sat, 23 Jan 2016 17:34:59 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-generics/</guid>
      <description>第26条：请不要在新代码中使用原生态类型 声明中具有一个或者多个类型参数（type parameter）的类或者接口就是泛型类或者接口。泛型类和</description>
    </item>
    
    <item>
      <title>《Effective Java》第4章类和接口</title>
      <link>https://malinkang.cn/post/effective-java-classes-and-interfaces/</link>
      <pubDate>Sat, 16 Jan 2016 17:34:17 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-classes-and-interfaces/</guid>
      <description>第13条：使类和成员的可访问性最小化 区分一个组件设计得好不好，唯一重要的因素在于，它对于外部的其他组件而言，是否隐藏了其内部数据和其他实现细</description>
    </item>
    
    <item>
      <title>《Effective Java》第3章对于所有对象都通用的方法</title>
      <link>https://malinkang.cn/post/effective-java-methods-common-to-all-objects/</link>
      <pubDate>Sat, 09 Jan 2016 15:18:19 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-methods-common-to-all-objects/</guid>
      <description>第8条：覆盖equals时请遵守通用约定 在覆盖equals方法的时候，你必须要遵守它的通用约定。 自反性（reflexive）。对于任何非nu</description>
    </item>
    
    <item>
      <title>《Effective Java》第2章创建和销毁对象</title>
      <link>https://malinkang.cn/post/effective-java-creating-and-destroying-objects/</link>
      <pubDate>Sat, 02 Jan 2016 14:18:11 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-creating-and-destroying-objects/</guid>
      <description>第1条：考虑用静态工厂方法替代构造器 创建类实例最常用的方法就是提供一个公有的构造器。此外，还可以提供一个公有的静态工厂方法（static factory m</description>
    </item>
    
    <item>
      <title>android反编译</title>
      <link>https://malinkang.cn/post/android-decompile/</link>
      <pubDate>Mon, 07 Dec 2015 15:48:40 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-decompile/</guid>
      <description>&lt;h3 id=&#34;apktool&#34;&gt;Apktool&lt;/h3&gt;
&lt;p&gt;Apktool 能够从APK中解析出资源文件，xml文件以及生成smail文件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第16章Java内存模型</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-the-java-momory-model/</link>
      <pubDate>Thu, 19 Nov 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-the-java-momory-model/</guid>
      <description>&lt;p&gt;本章将介绍Java内存模型的底层需求以及锁提供的保证，此外还将介绍在本书给出的一些高层设计原则背后的原理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第15章原子变量与非阻塞同步机制</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-atomic-variables-and-nonblocking-synchronization/</link>
      <pubDate>Thu, 12 Nov 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-atomic-variables-and-nonblocking-synchronization/</guid>
      <description>&lt;p&gt;在&lt;code&gt;java.util.concurrent&lt;/code&gt;包的许多类中，例如&lt;code&gt;Semaphore&lt;/code&gt;和&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;，都提供了比&lt;code&gt;synchronized&lt;/code&gt;机制更高的性能和可伸缩性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第14章构建自定义的同步工具</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-building-custom-synchronizers/</link>
      <pubDate>Thu, 05 Nov 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-building-custom-synchronizers/</guid>
      <description>&lt;p&gt;类库包含了许多存在状态依赖性的类，例如&lt;code&gt;FutureTask&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt;和&lt;code&gt;BlockingQueue&lt;/code&gt;等。在这些类的一些操作中有着基于状态的前提条件，例如，不能从一个空的队列中删除元素，或者获取一个尚未结束的任务的计算结果，在这些操作可以执行之前，必须等到队列进入“非空”状态，或者任务进入“已完成”状态。&lt;/p&gt;
&lt;p&gt;创建状态依赖类的最简单方法通常是在类库中现有状态依赖类的基础上进行构造。如果类库没有提供你需要的功能，那么还可以使用&lt;code&gt;Java&lt;/code&gt;语言和类库提供的底层机制来构造自己的同步机制，包括内置的条件队列、显式的&lt;code&gt;Condition&lt;/code&gt;对象以及&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;框架。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第13章显式锁</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-explicit-locks/</link>
      <pubDate>Thu, 29 Oct 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-explicit-locks/</guid>
      <description>&lt;p&gt;在&lt;code&gt;Java 5.0&lt;/code&gt;之前，在协调对共享对象的访问时可以使用的机制只有&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;volatile&lt;/code&gt;。Java5.0增加了一种新的机制：&lt;code&gt;ReentrantLock&lt;/code&gt;。&lt;code&gt;ReentrantLock&lt;/code&gt;并不是一种替代内置锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第8章线程池的使用</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-applying-thread-pools/</link>
      <pubDate>Thu, 22 Oct 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-applying-thread-pools/</guid>
      <description>&lt;p&gt;本章将介绍对线程池进行配置与调优的一些高级选项，并分析在使用任务执行框架时需要注意的各种危险，以及一些使用&lt;code&gt;Executor&lt;/code&gt;的高级示例。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第6章执行任务</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-task-execution/</link>
      <pubDate>Thu, 15 Oct 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-task-execution/</guid>
      <description>&lt;p&gt;大多数并发应用程序都是围绕“任务执行”来构造的，任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第7章取消与关闭</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-cancellation-and-shutdown/</link>
      <pubDate>Thu, 15 Oct 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-cancellation-and-shutdown/</guid>
      <description>&lt;p&gt;任务和线程的启动很容易，在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然后，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。&lt;/p&gt;
&lt;p&gt;要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断（Interruption），这是一种协作机制，能够使一个线程终止另一个线程的当前工作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第5章基础构建模块</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-building-blocks/</link>
      <pubDate>Thu, 08 Oct 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-building-blocks/</guid>
      <description>&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;平台类库包含了丰富的并发基础构建模块，例如线程安全的容器类以及各种用于协调多个相互协作的线程控制流的同步工具类（Synchronizer）。本章将介绍其中一些最有用的开发构建模块，特别是在Java5.0和Java6中引入的一些新模块，以及在使用这些模块来构造并发应用程序时的一些常用模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第3章对象的共享</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-sharing-objects/</link>
      <pubDate>Thu, 01 Oct 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-sharing-objects/</guid>
      <description>&lt;p&gt;我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字&lt;code&gt;synchronized&lt;/code&gt;只能用于实现原子性或者确定临界区。同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来保证对象被安全地发布。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Java并发编程实战》第2章线程安全性</title>
      <link>https://malinkang.cn/post/java-currency-in-practice-thread-safety/</link>
      <pubDate>Thu, 24 Sep 2015 10:53:22 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-currency-in-practice-thread-safety/</guid>
      <description>&lt;p&gt;一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要使得对象时线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java动态代理</title>
      <link>https://malinkang.cn/post/java-dynamic-proxy/</link>
      <pubDate>Sat, 29 Nov 2014 17:36:33 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/java-dynamic-proxy/</guid>
      <description>代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替”实际“对象的对象。这些操作通常涉及与“实际”对象的通信，因此代</description>
    </item>
    
    <item>
      <title>Android Studio常用插件</title>
      <link>https://malinkang.cn/post/android-studio-plugins/</link>
      <pubDate>Sun, 15 Jun 2014 10:40:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-studio-plugins/</guid>
      <description>ButterKnifeZelezny android-parcelable-intellij-plugin GsonFormat android-selector-chapek adb-idea android-material-design-icon-generator-plugin 扩展阅读 Android-Studio-Plugins Android Studio有哪些非常好用的插件？</description>
    </item>
    
    <item>
      <title>sqlite常用语法总结</title>
      <link>https://malinkang.cn/post/sqlite/</link>
      <pubDate>Wed, 26 Mar 2014 17:23:24 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/sqlite/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第21章并发</title>
      <link>https://malinkang.cn/post/thinking-in-java-concurrency/</link>
      <pubDate>Tue, 30 Jul 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-concurrency/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第20章注解</title>
      <link>https://malinkang.cn/post/thinking-in-java-annotations/</link>
      <pubDate>Tue, 23 Jul 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-annotations/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第19章枚举类型</title>
      <link>https://malinkang.cn/post/thinking-in-java-enumerated-types/</link>
      <pubDate>Tue, 16 Jul 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-enumerated-types/</guid>
      <description>19.1 基本enum特性 调用enum的values()方法，可以遍历enum实例。values()方法返回enum实例的数组，而且该数组中的元素严</description>
    </item>
    
    <item>
      <title>《Java编程思想》第18章I/O系统</title>
      <link>https://malinkang.cn/post/thinking-in-java-i-o/</link>
      <pubDate>Tue, 09 Jul 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-i-o/</guid>
      <description>1.File类 1.1 目录列表器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //: io/DirList.java // Display a directory listing using regular expressions. // {Args: &amp;#34;D.*\.java&amp;#34;} import java.util.regex.*; import java.io.*; import java.util.*; public class DirList</description>
    </item>
    
    <item>
      <title>《Java编程思想》第17章容器深入研究</title>
      <link>https://malinkang.cn/post/thinking-in-java-containers-in-depth/</link>
      <pubDate>Tue, 02 Jul 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-containers-in-depth/</guid>
      <description>1.完整的容器分类法 2.填充容器 与Arrays版本一样，此fill()方法也是只复制同一个对象引用来填充整个容器的，并且只对List对象有用</description>
    </item>
    
    <item>
      <title>《Java编程思想》第16章数组</title>
      <link>https://malinkang.cn/post/thinking-in-java-arrays/</link>
      <pubDate>Tue, 25 Jun 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-arrays/</guid>
      <description>1.数组为什么特殊 数组与其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。在Java中，数组是一种效率最高的存储和随机访问对</description>
    </item>
    
    <item>
      <title>《Java编程思想》第15章泛型</title>
      <link>https://malinkang.cn/post/thinking-in-java-generics/</link>
      <pubDate>Tue, 18 Jun 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-generics/</guid>
      <description>一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大</description>
    </item>
    
    <item>
      <title>《Java编程思想》第14章类型信息</title>
      <link>https://malinkang.cn/post/thinking-in-java-type-information/</link>
      <pubDate>Tue, 11 Jun 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-type-information/</guid>
      <description>14.1 为什么需要RTTI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 abstract class Shape{ void draw(){ System.out.println(this + &amp;#34;.draw()&amp;#34;); } abstract public String toString(); } class Circle extends Shape{ public String</description>
    </item>
    
    <item>
      <title>《Java编程思想》第13章字符串</title>
      <link>https://malinkang.cn/post/thinking-in-java-strings/</link>
      <pubDate>Tue, 04 Jun 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-strings/</guid>
      <description>第13章 字符串 13.1 不可变String 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Immutable { public static String upcase(String s){ return s.toUpperCase(); } public static void main(String[] args) { String q = &amp;#34;howdy&amp;#34;; System.out.println(q); String qq = upcase(q); System.out.println(qq); System.out.println(q); } } 当把q传给upca</description>
    </item>
    
    <item>
      <title>《Java编程思想》第12章通过异常处理错误</title>
      <link>https://malinkang.cn/post/thinking-in-java-error-handling-with-exceptions/</link>
      <pubDate>Tue, 28 May 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-error-handling-with-exceptions/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第11章持有对象</title>
      <link>https://malinkang.cn/post/thinking-in-java-holding-your-objects/</link>
      <pubDate>Tue, 21 May 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-holding-your-objects/</guid>
      <description>第11章 持有对象 1.泛型和类型安全的容器 Apple和Orange都放置在了容器中，然后将它们取出。正常情况下，Java编译器会报告警告信息，</description>
    </item>
    
    <item>
      <title>《Java编程思想》第10章内部类</title>
      <link>https://malinkang.cn/post/thinking-in-java-inner-classes/</link>
      <pubDate>Tue, 14 May 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-inner-classes/</guid>
      <description>1.创建内部类 创建内部类的方式就是把类的定义置于外围类的里面。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Parcel1 { class Contents</description>
    </item>
    
    <item>
      <title>《Java编程思想》第9章接口</title>
      <link>https://malinkang.cn/post/thinking-in-java-interfaces/</link>
      <pubDate>Tue, 07 May 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-interfaces/</guid>
      <description>1.抽象类和抽象方法 2.接口 3.完全解耦 4.Java的多重继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public interface CanFight { void fight(); }</description>
    </item>
    
    <item>
      <title>《Java编程思想》第8章多态</title>
      <link>https://malinkang.cn/post/thinking-in-java-polymorphism/</link>
      <pubDate>Tue, 30 Apr 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-polymorphism/</guid>
      <description>8.1 再论向上转型 对某个对象的引用视为对其基类型的引用的做法被称作向上转型。 单独创建一个奏乐符（Note）类： 1 2 3 4 5 6 7 //: polymorphism/music/Note.java // Notes to play on musical instruments. package</description>
    </item>
    
    <item>
      <title>《Java编程思想》第7章复用类</title>
      <link>https://malinkang.cn/post/thinking-in-java-reusing-classes/</link>
      <pubDate>Tue, 23 Apr 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-reusing-classes/</guid>
      <description>7.1 组合语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //: reusing/SprinklerSystem.java // Composition for code reuse. class WaterSource { private String s; WaterSource() { System.out.println(&amp;#34;WaterSource()&amp;#34;); s = &amp;#34;Constructed&amp;#34;; } public String toString() { return s; } } public class</description>
    </item>
    
    <item>
      <title>《Java编程思想》第6章访问权限控制</title>
      <link>https://malinkang.cn/post/thinking-in-java-access-control/</link>
      <pubDate>Tue, 16 Apr 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-access-control/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第5章初始化与清理</title>
      <link>https://malinkang.cn/post/thinking-in-java-initialization-and-cleanup/</link>
      <pubDate>Tue, 09 Apr 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-initialization-and-cleanup/</guid>
      <description>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。 初始化和清理（cleanup）正是涉及安全的两个问题。C++引入</description>
    </item>
    
    <item>
      <title>《Java编程思想》第4章控制流程</title>
      <link>https://malinkang.cn/post/thinking-in-java-controlling-execution/</link>
      <pubDate>Tue, 02 Apr 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-controlling-execution/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第3章操作符</title>
      <link>https://malinkang.cn/post/thinking-in-java-operators/</link>
      <pubDate>Tue, 26 Mar 2013 13:39:36 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-operators/</guid>
      <description></description>
    </item>
    
    <item>
      <title>《Java编程思想》第2章一切都是对象</title>
      <link>https://malinkang.cn/post/thinking-in-java-everything-is-an-object/</link>
      <pubDate>Tue, 19 Mar 2013 16:26:34 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/thinking-in-java-everything-is-an-object/</guid>
      <description>2.2 必须由你创建所有对象 2.2.1 存储到什么地方 2.2.2 特例：基本类型 在程序设计中经常用到一系列类型，它们需要特殊对待。可以把它们想象成“基本”类型。之所以</description>
    </item>
    
    <item>
      <title>bindService流程分析</title>
      <link>https://malinkang.cn/post/framework-bind-service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/framework-bind-service/</guid>
      <description>{%plantuml%} &amp;ndash;&amp;gt; ContextWrapper: bindService ContextWrapper&amp;ndash;&amp;gt; ContextImpl: bindService ContextImpl&amp;ndash;&amp;gt; ContextImpl: bindServiceCommon ContextImpl&amp;ndash;&amp;gt; LoadedApk: getServiceDispatcher LoadedApk&amp;ndash;&amp;gt; ServiceDispatcher: 创建ServiceDispatcher ServiceDispatcher&amp;ndash;&amp;gt; InnerConnection: 创建InnerConnection LoadedApk&amp;ndash;&amp;gt; ContextImpl: 返回ServiceDispat</description>
    </item>
    
    <item>
      <title>Retrofit源码分析</title>
      <link>https://malinkang.cn/post/retrofit-source-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/retrofit-source-analysis/</guid>
      <description>Retrofit源码分析 流程分析 Retrofit执行流程可以分为两部分： 创建ServiceMethod。 调用ServiceMethod的in</description>
    </item>
    
  </channel>
</rss>

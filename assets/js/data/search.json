[ { "title": "系统闹钟源码分析", "url": "/posts/deskclock-analysis/", "categories": "", "tags": "源码分析", "date": "2021-01-19 17:21:04 +0800", "snippet": "核心类 UI部分 DeskClock：主界面，由ViewPager实现。 DeskClockFragment：首页四个Fragment的基类。 AlarmClockFragment：闹钟Fragment ClockFragment：时钟Fragment StopwatchFragment：秒表Fragment TimerFragment：定时器Fragment 数据 ClockDatabaseHelper：数据库Helper，闹钟应用创建了两表，表alarm_templa..." }, { "title": "绑定服务", "url": "/posts/bound-services/", "categories": "", "tags": "Android", "date": "2020-12-15 03:18:41 +0800", "snippet": "绑定服务是 Service 类的实现，可让其他应用与其进行绑定和交互。如要为服务提供绑定，您必须实现 onBind() 回调方法。该方法会返回 IBinder 对象，该对象定义的编程接口可供客户端用来与服务进行交互。客户端通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。bindService() 的返回值表明所请求的服务是否存在，以及是否允许客户端访问该服务。当创建客户端与服务之间的连接时，Android 系统会调用 ServiceConnection 上的 onServiceConnected()..." }, { "title": "WorkManager源码分析", "url": "/posts/workmanager-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-12-08 04:40:56 +0800", "snippet": "WorkManagerWorkManger是一个单例对象, 但是从例子代码中没有看的调用初始化的地方。通过文档可知 WorkManager有两种初始化方式: 应用启动之后, 它自己自动初始化 按需初始化, 到了需要用到的地方才初始化。可以避免初始化影响应用的启动速度。自动初始化WorkManagerInitializer继承ContentProvider。在应用启动之后会调用 onCreate(), 所以自动初始化就是在 onCreate() 中执行WorkManager 的初始化。public class WorkManagerInitializer extends Content..." }, { "title": "ButterKnife源码分析", "url": "/posts/butterknife-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-12-03 00:37:06 +0800", "snippet": "本文分析的源码为8.4.0。项目结构butterknife包含ButterKnife核心的Api，如ButterKnife。butterknife-annotations包含了所有定义的注解。butterknife-compiler包含了生成模板代码的代码。这里我们重点研究ButterKnife是如何生成模板代码以及在我们的类中是如何调用的。核心类ViewBinding是一个接口，有两个直接的子类FieldViewBinding和MethodViewBinding。FieldViewBinding封装了使用@BindView注解的Field的信息。private final String..." }, { "title": "RxJava源码分析", "url": "/posts/rxjava-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-11-28 07:47:34 +0800", "snippet": "RxJava创建过程create()调用create()创建Observable。Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { @Override public void subscribe(@NonNull ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Throwable { emitter.onNext(2); }}).subscribe(new Consumer&amp;lt;Intege..." }, { "title": "Leakcanary源码分析", "url": "/posts/leakcanary-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-11-26 04:10:28 +0800", "snippet": "" }, { "title": "Glide源码分析", "url": "/posts/glide-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-11-26 04:07:31 +0800", "snippet": "Glide源码分析Glide的使用非常简单只需要调用with、load into三个方法。 GlideApp.with(this) .load(url) .into(imageView);接下来，我们依次分析这三个方法。with()//Glide.javapublic static RequestManager with(@NonNull Activity activity) { //先获取RequestManagerRetriever对象 //调用RequestManagerRetriever的get方法获取RequestManager return ..." }, { "title": "Okio源码分析", "url": "/posts/okio-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-11-26 04:07:14 +0800", "snippet": "" }, { "title": "Okhttp源码分析", "url": "/posts/okhttp-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-11-26 04:01:47 +0800", "snippet": "Okhttp基本流程分析基本流程 创建RequestBody 创建Request 创建OkhttpClient 调用newCall创建Call对象 执行异步或同步操作。 创建Socket连接 发送请求并处理返回结果创建RequestBodyRequestBody主要通过writeTo方法将请求内容写入到BufferedSink。RequestBody提供了3个create静态方法来创建RequestBody，此外RequestBody还包含两个子类。FormBody用于表单提交，MultipartBody用于多内容提交。创建RequestRequest对象包含如下信息fin..." }, { "title": "ARouter源码分析", "url": "/posts/arouter-source-analysis/", "categories": "", "tags": "源码分析", "date": "2020-11-24 19:14:29 +0800", "snippet": "ARouter原理如下编译期，会扫描@Route注解，将注解里的信息封装成一个RouteMeta对象。并生成一个辅助类ARouter$$Group$$groupName，groupName即分组的名字，这也意味着同一个group只会生成一个辅助类。该类继承自IRouteGroup，有一个loadInto()方法。在运行时，调用loadInto()方法，将@Route中的path作为key，封装的RouteMeta作为value存储到Warehouse的routes中。每一个module都会生成一个ARouter$$Root$$moduleName ，该类集成自IRouteRoot，在运行..." }, { "title": "Recyclerview源码分析三", "url": "/posts/recyclerview-analysis-3/", "categories": "", "tags": "Android, RecyclerView", "date": "2020-09-04 16:39:09 +0800", "snippet": "上一篇分析RecyclerView整体流程的时候提到，RecyclerView缓存机制比较复杂，所以这一篇单独分析一下RecyclerView的缓存机制。Recycler中的缓存Recycler中定义了三个list来缓存ViewHolder，那这几个缓存有什么区别呢。我们先来看mAttachedScrap和mChangedScrap。Recycler的scrapView中调用mAttachedScrap和mChangedScrap的add方法。//LayoutManager的scrapOrRecycleView方法private void scrapOrRecycleView(Recyc..." }, { "title": "Recyclerview源码分析二", "url": "/posts/recyclerview-analysis-2/", "categories": "", "tags": "Android, RecyclerView", "date": "2020-09-03 16:39:09 +0800", "snippet": "在上一篇文章中，我们主要分析了RecyclerView中的几个重要的内部类。今天我们就把它们串起来，看它们分别是如何工作的。RecyclerView继承自ViewGroup。所以肯定是通过addView的方式来将所有的item添加进来的。所以在分析过程中，我先找到addView的调用位置，然后一步步倒推，看view是如何获取的。首先，在创建ChildHelper时传入的Callback中调用了addView()方法。除了调用了addView()之外，还调用了removeViewAt等方法。private void initChildrenHelper() { mChildHelpe..." }, { "title": "Recyclerview源码分析一", "url": "/posts/recyclerview-analysis-1/", "categories": "", "tags": "Android, RecyclerView", "date": "2020-09-02 16:39:09 +0800", "snippet": "RecyclerView是我们开发中最常用的控件，RecyclerView是如何工作的，如何处理缓存的有助于解决一些使用RecyclerView的bug和优化RecyclerView。准备源码分析源码之前我们需要先准备一份源码。 按照官方文档下载一份support源码 用AndroidStudio打开源码 #进入support目录cd androidx-master-dev/frameworks/support./studiow 我们可以在源码中添加一些日志 打包 ./gradlew createArchive 创建一个工程，在项目的..." }, { "title": "什么是响应式编程", "url": "/posts/what-is-reactive-programming/", "categories": "", "tags": "", "date": "2020-07-28 10:44:19 +0800", "snippet": "最近被人问起什么是响应式编程，虽然使用RxJava已经五六年了，但真正让我用一句话来概括什么是响应式编程还真有点困难。打开google，搜索什么是函数编程，看了几遍文章也没有明确的答案，这里谈谈自己的理解。响应式编程一个核心的概念是流（stream）。可以基于任何东西创建数据流。流非常轻便，并且无处不在，任何东西都可以是一个流：变量，用户输入，属性，缓存，数据结构等等。除此之外，我们有很多功能强大的函数，可以对这些流进行合并、过滤、转变等。流可以被监听，对流的 “侦听” 又称为 订阅(subscribing)，而定义的函数即为 观察者(observer)，流就是可被观察的对象(obser..." }, { "title": "bindService流程分析", "url": "/posts/framework-bind-service/", "categories": "", "tags": "源码分析", "date": "2020-03-01 03:18:41 +0800", "snippet": "ContextWrapperbindService//frameworks/base/core/java/android/content/ContextWrapper.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn,int flags) { return mBase.bindService(service, conn, flags);}ContextImplbindService//frameworks/base/core/java/android/app/ContextI..." }, { "title": "startActivity流程分析", "url": "/posts/start-activity/", "categories": "", "tags": "", "date": "2020-02-27 16:07:48 +0800", "snippet": "Activity的启动过程分为两种，一种是根Activity的启动过程，另一种是普通Activity的启动过程。根Activity指的是应用程序启动的第一个Activity，因此根Activity的启动过程一般情况下也可以理解为应用程序的启动过程。普通Activity指的是除应用程序启动的第一个Activity之外的其他Activity。Activity的启动过程比较复杂，因此这里分为3个部分来讲，分别是 Launcher请求AMS过程 AMS到ApplicationThread的调用过程 ActivityThread启动Activity。Launcher请求AMS过程Launch..." }, { "title": "创建应用程序进程", "url": "/posts/create-application-process/", "categories": "", "tags": "系统源码分析", "date": "2020-02-27 09:55:01 +0800", "snippet": "一个App打开另一个App的Activity或者绑定另外一个App的服务的过程，如果另外一个App的进程不存在，都会先创建另外一个App的进程，再执行后续操作。应用程序进程创建过程可以分为以下几部分： AMS发送启动应用程序进程请求 Zygote接收请求并创建应用程序进程。 ActivityThread初始化AMS发送启动应用程序进程请求这里先给出AMS发送启动应用程序进程请求过程的时序图，然后对每一个步骤进行详细分析，如图所示。ATMS#startProcessAsync在Activity的启动过程中，会调用ATMS的startProcessAsync方法来创建新的进程。star..." }, { "title": "WindowManagerService分析", "url": "/posts/WindowManagerService/", "categories": "", "tags": "源码分析", "date": "2020-02-24 01:19:13 +0800", "snippet": "WindowWindow字面意思为窗口，是一个抽象类，负责管理View，它的唯一子类为PhoneWindow。它的官方定义如下： Abstract base class for a top-level window look and behavior policy. An instance of this class should be used as the top-level view added to the window manager. It provides standard UI policies such as a background, title area, de..." }, { "title": "AMS分析", "url": "/posts/framework-ams/", "categories": "", "tags": "源码分析", "date": "2020-02-22 22:48:10 +0800", "snippet": "public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStat..." }, { "title": "Parcel源码分析", "url": "/posts/framework-parcel/", "categories": "", "tags": "源码分析", "date": "2020-02-20 23:11:27 +0800", "snippet": "Parcel.java//frameworks/base/core/java/android/os/Parcel.java//frameworks/base/core/jni/android_os_Parcel.cppstatic jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr){ Parcel* parcel = reinterpret_cast&amp;lt;Parcel*&amp;gt;(nativePtr); if (parcel != NULL..." }, { "title": "添加和获取服务", "url": "/posts/framework-add-and-get-service/", "categories": "", "tags": "源码分析", "date": "2020-02-16 01:03:15 +0800", "snippet": "ServiceManageraddServicepublic static void addService(String name, IBinder service) { try { getIServiceManager().addService(name, service, false);//添加服务 } catch (RemoteException e) { Log.e(TAG, &quot;error in addService&quot;, e); }}ServiceManagerProxyaddService//frameworks..." }, { "title": "获取ServiceManager", "url": "/posts/framework-get-sm/", "categories": "", "tags": "源码分析", "date": "2020-02-08 17:44:44 +0800", "snippet": "ServiceManager的addService和getService方法都会首先调用getIServiceManager来获取ServiceManager。类图ServiceManageraddService//frameworks/base/core/java/android/os/ServiceManager.javapublic static void addService(String name, IBinder service) { try { getIServiceManager().addService(name, service, false);/..." }, { "title": "启动ServiceManager", "url": "/posts/framework-start-sm/", "categories": "", "tags": "源码分析", "date": "2020-02-02 06:07:20 +0800", "snippet": "ServiceManager在init.rc中启动的。//system/core/rootdir/init.rcservice servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart r..." }, { "title": "Binder驱动分析", "url": "/posts/framework-binder-driver/", "categories": "", "tags": "源码分析", "date": "2020-01-25 17:44:44 +0800", "snippet": "参考 理解Android Binder机制(1/3)：驱动篇" }, { "title": "SystemServer启动流程", "url": "/posts/framework-systemserver/", "categories": "", "tags": "源码分析", "date": "2020-01-18 22:04:10 +0800", "snippet": "SystemServer进程主要用于创建系统服务，我们熟知的AMS、WMS和PMS都是由它来创建的。一旦在init.rc中为Zygote制定了启动参数--start-system-server，那么ZygoteInit就会调用startSystemServer来启动SystemServer集成。run//frameworks/base/services/java/com/android/server/SystemServer.javaprivate void run() { try { Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_S..." }, { "title": "Zygote进程启动流程", "url": "/posts/framework-zygote/", "categories": "", "tags": "源码分析", "date": "2020-01-11 23:01:48 +0800", "snippet": "在Android系统中，应用程序进程以及运行系统的关键服务的SystemServer进程都是由Zygote进程来创建的，我们也将它称为孵化器。它通过fork（复制进程）的形式来创建应用程序进程和SystemServer进程。Zygote进程是在init进程启动时创建的，起初Zygote进程的名称并不是叫“zygote”，而是叫“app_process”，这个名称是在Android.mk中定义的，Zygote进程启动后，Linux系统下的pctrl系统会调用app_process，将其名称换成了“zygote”。Zygote启动脚本分析在init.rc文件中采用了import引入Zygot..." }, { "title": "Epoxy Models", "url": "/posts/Epoxy-Models/", "categories": "", "tags": "Java, 读书笔记", "date": "2020-01-05 23:52:23 +0800", "snippet": "概览（Overview） Epoxy uses EpoxyModel objects to decide which views to display and how to bind data to them. This is similar to the popular ViewModel pattern. Models also allow you to control other aspects of the view, such as the grid span size, id, and saved state.Epoxy使用EpoxyModel对象来确定要显示的view以及..." }, { "title": "init启动流程分析", "url": "/posts/framework-init/", "categories": "", "tags": "源码分析", "date": "2020-01-04 23:01:48 +0800", "snippet": "" }, { "title": "Improve App Performance With Kotlin Coroutines", "url": "/posts/Improve-app-performance-with-Kotlin-coroutines/", "categories": "", "tags": "", "date": "2019-10-15 19:02:36 +0800", "snippet": "原文协程是一种并发设计模式，您可以在Android上使用它来简化异步执行的代码。 Coroutines在版本1.3中添加到Kotlin，并基于其他语言的既定概念。在Android上，协同程序有助于解决两个主要问题： 管理长时间运行的任务，否则可能会阻止主线程并导致应用冻结。 提供主安全性，或从主线程安全地调用网络或磁盘操作。本主题描述了如何使用Kotlin协同程序解决这些问题，使您能够编写更清晰，更简洁的应用程序代码。管理长时间运行的任务在Android上，每个应用程序都有一个主线程来处理用户界面并管理用户交互。如果您的应用程序为主线程分配了太多工作，那么应用程序可能会明显卡顿或运行..." }, { "title": "Dex文件格式分析", "url": "/posts/dex-file-format/", "categories": "", "tags": "", "date": "2019-09-27 10:04:55 +0800", "snippet": "在刚学习Java的时候我们都会写一个HelloWorld的示例。public class HelloWorld{ public static void main(String[] args){ System.out.println(&quot;Hello,world!&quot;); }}然后通过javac命令编译成字节码，然后调用java命令机执行字节码。我们如何像java一样在命令行里直接在命令行输出Hello,world!呢。具体要执行如下操作：将.class文件转换成.dex文件dx --dex --output=HelloWorld.dex Hello..." }, { "title": "Activity的启动流程", "url": "/posts/android-activity-launch-process/", "categories": "", "tags": "", "date": "2019-09-24 15:53:26 +0800", "snippet": "App启动的整体流程分为以下7个阶段。 Launcher通知AMS，要启动App，而且指定要启动App的哪个页面（也就是首页）。 AMS通知Launcher, “好了我知道了，没你什么事了”。同时，把要启动的首页记下来。 Launcher当前页面进入Paused状态，然后通知AMS, “我睡了，你可以去找App了”。 AMS检查App是否已经启动了。是，则唤起App即可。否，就要启动一个新的进程。AMS在新进程中创建一个ActivityThread对象，启动其中的main函数。 App启动后，通知AMS, “我启动好了”。 AMS翻出之前在2中存的值，告诉App，启动哪个页面..." }, { "title": "【译】避免Android中内存泄漏的9种方法", "url": "/posts/9-ways-to-avoid-memory-leaks-in-android/", "categories": "", "tags": "Android", "date": "2019-06-10 14:33:57 +0800", "snippet": "原文，本文介绍了，引发内存泄露的常见情况，并给出了对应的修复方法。 I have been an android developer for quite some time now. And I realised（意识到） that most of that time, I tend to spend on adding new features to an app or working on visually enhancements of the app, rather than focusing on the core issues like performance and qu..." }, { "title": "Handler的使用和原理分析", "url": "/posts/android-handler/", "categories": "", "tags": "Android, 技术", "date": "2019-04-26 11:22:09 +0800", "snippet": "使用Handler每个应用程序都有自己的特殊线程来运行UI对象，例如View对象;这个线程称为UI线程。在Android中，不允许非UI线程访问和修改UI对象。但是在实际的开发中，很多地方要在非UI线程中修改UI对象。比如下载网络图片并将图片设置给ImageView。Handler允许您发送和处理与线程的MessageQueue关联的Message和Runnable对象。每个Handler实例都与一个线程和该线程的消息队列相关联。当您创建一个新的Handler时，它被绑定到正在创建它的线程的线程/消息队列 - 从那时起，它将消息和runnables传递给该消息队列并在消息出来时执行它们队..." }, { "title": "Flutter Http请求", "url": "/posts/flutter-http/", "categories": "", "tags": "", "date": "2019-04-23 16:34:46 +0800", "snippet": "Dart提供了http package来进行网络请求。1.添加http packagedependencies: http: &amp;lt;latest_version&amp;gt;2.发起网络请求Get请求Future&amp;lt;Post&amp;gt; fetchPost() async { final response = await http.get(&#39;https://jsonplaceholder.typicode.com/posts/1&#39;); //请求 final json = JSON.decode(response.body); //解析 ..." }, { "title": "Flutter Json解析", "url": "/posts/flutter-json/", "categories": "", "tags": "", "date": "2019-04-23 16:15:19 +0800", "snippet": "import &#39;dart:convert&#39;;void main() { var jsonString = &#39;{&quot;name&quot;: &quot;John Smith&quot;,&quot;email&quot;: &quot;john@example.com&quot;}&#39;; Map&amp;lt;String, dynamic&amp;gt; user = jsonDecode(jsonString); print(&#39;Howdy, ${user[&#39;name&#39;]}!&#39;); print(&#39;We ..." }, { "title": "Dart语法总结", "url": "/posts/dart/", "categories": "", "tags": "", "date": "2019-03-31 15:50:08 +0800", "snippet": "" }, { "title": "Column和Row详解", "url": "/posts/flutter-widget-column/", "categories": "", "tags": "", "date": "2019-03-19 14:21:37 +0800", "snippet": "MainAxisAlignmentScaffold( appBar: AppBar(title: Text(&#39;Flutter&#39;)), body: Column( children: &amp;lt;Widget&amp;gt;[ Text(&quot;MainAxisAlignment.start&quot;,style:TextStyle( color: Colors.blueAccent, fontSize: 18 )), Row( m..." }, { "title": "Android动态化", "url": "/posts/android-dynamic/", "categories": "", "tags": "", "date": "2019-03-14 15:18:46 +0800", "snippet": "移动互联网已经发展十年了，随着业务成熟和功能的相对稳定，整体重心开始偏向运营，强烈的运营需求对客户端架构和发布模式都提出了更高的要求。如果每个修改都需要经历开发、上线、版本覆盖等漫长的过程，根本无法达到快速响应的要求。常见的动态化方案移动端动态化方案在最近几年一直是大家关注的重点，虽然它已经发展了很多年，但是每年都会有新的变化，这里我们先来看看各大公司有哪些已知的动态化方案。动态化方案分为下面四种类型： Web 容器增强。基于 H5 实现，但是还有离线包等各种优化手段加持，代表方案有 PWA、腾讯的 VasSonic、淘宝的 zCache 以及大部分的小程序方案。 虚拟运行环境。使用..." }, { "title": "Android Build", "url": "/posts/android-build/", "categories": "", "tags": "", "date": "2019-03-14 15:18:46 +0800", "snippet": "D8Android Studio 3.0 推出了d8，并在3.1正式成为默认工具。它的作用是将“.class”文件编译为Dex文件，取代之前的dx工具。R8R8 在 Android Studio 3.1 中引入，志向更加高远，它的目标是取代 ProGuard 和 d8。我们可以直接使用 R8 把“.class”文件变成 Dex。同时，R8 还支持 ProGuard 中混淆、裁剪、优化这三大功能。参考 配置构建 签署您的应用 打包流程梳理 腾讯多渠道打包VasDolly 微信Android资源混淆打包工具 Android安装包相关知识汇总 美团多渠道打包Walle apks..." }, { "title": "Android网络优化", "url": "/posts/android-network-performance/", "categories": "", "tags": "Android", "date": "2019-03-08 09:54:39 +0800", "snippet": "在讲怎么去优化网络之前，我想先明确一下所谓的网络优化，究竟指的是什么？在我看来，核心内容有以下三个： 速度。在网络正常或者良好的时候，怎样更好地利用带宽，进一步提升网络请求速度。 弱网络。移动端网络复杂多变，在出现网络连接不稳定的时候，怎样最大程度保证网络的连通性。 安全。网络安全不容忽视，怎样有效防止被第三方劫持、窃听甚至篡改。" }, { "title": "Android优化之UI优化", "url": "/posts/android-ui-performance/", "categories": "", "tags": "Android", "date": "2019-03-07 16:49:52 +0800", "snippet": "UI渲染的背景知识1.屏幕与适配2.CPU与GPU3.OpenGL与VulkanAndroid渲染的演进1.Android 4.0：开启硬件加速2.Android 4.1：Project Butter3.Android 5.0：RenderThreadUI渲染测量1.gfxinfo2.SurfaceFlingerUI优化的常规手段1.尽量使用硬件加速2.Create View优化3.measure/layout优化UI优化的进阶手段1.Litho：异步布局异步布局界面扁平化优化RecyclerView2.Flutter：自己的布局+渲染引擎3.RenderThread与RenderScript" }, { "title": "Android电池优化", "url": "/posts/android-battery-performance/", "categories": "", "tags": "Android", "date": "2019-03-07 10:02:53 +0800", "snippet": "耗电的背景知识1.电池技术手机电池的一些关键指标： 电池容量 充电时间 寿命 安全性 2.电量和硬件3.电量和应用程序Android耗电的演进历程1.野蛮生长：Pre Android 5.02.逐步收紧：Android5.0~Android8.03.最严限制：Android9.0耗电优化1.什么是耗电优化耗电优化的第一个方向是优化应用的后台耗电。耗电优化的第二个方向是符合系统的规则，让系统认为你耗电是正常的。2.耗电优化的难点 缺乏现场，无法复现。 信息不全，难以定位。 无法评估结果。3.耗电优化的方法耗电监控1.Android..." }, { "title": "Android存储优化", "url": "/posts/android-storage-performance/", "categories": "", "tags": "Android", "date": "2019-03-05 16:02:05 +0800", "snippet": "Android的存储基础1.Android分区Android系统可以通过/proc/partitions或者df命令来查看各个分区的情况。2.Android安全存储第一、权限控制第二、数据加密常见的数据存储方法1.关键要素2.存储选项第一，SharePreference的使用第二，ContentProvider的使用对象的序列化1.SerializableSerializable的原理Serializable的进阶Serializable的注意事项2.ParcelableParcelable的永久存储Parcelable的注意事项3.Serialhttps://github.com/tw..." }, { "title": "Android优化之安装包大小优化", "url": "/posts/android-reduce-apk-size/", "categories": "", "tags": "Android", "date": "2019-03-05 16:00:24 +0800", "snippet": "1.为什么要优化包体积 下载转化率 推广成本 应用市场2.包体积与应用性能包体积除了转化率的影响，它对我们应用性能还有哪些影响呢？ 安装时间。文件拷贝、Library 解压、编译 ODEX、签名校验，特别对于 Android 5.0 和 6.0 系统来说（Android 7.0 之后有了混合编译），微信 13 个 Dex 光是编译 ODEX 的时间可能就要 5 分钟。 运行内存。在内存优化的时候我们就说过，Resource 资源、Library 以及 Dex 类加载这些都会占用不少的内存。 ROM 空间。100MB 的安装包，启动解压之后很有可能就超过 200MB 了。对低端..." }, { "title": "AndroidI/O优化", "url": "/posts/android-io-performance/", "categories": "", "tags": "Android", "date": "2019-03-05 15:57:29 +0800", "snippet": "I/O的基本知识1.文件系统2.磁盘Android I/O1.Android闪存2.两个疑问I/O的性能评估1.I/O性能指标2.I/O测量第一种方法：使用proc第二种方法：使用strace第三种方法：使用vmstatI/O跟踪1.Java Hook2.Native Hook3.监控内容线上监控1.主线程I/O2.读写Buffer过小3.重复读4.资源泄漏IO的启动与优化" }, { "title": "Android优化之内存优化", "url": "/posts/android-memory-performance/", "categories": "", "tags": "Android", "date": "2019-03-05 15:10:02 +0800", "snippet": "目录 使用内存效率更高的代码结构 谨慎使用服务 使用经过优化的数据容器 谨慎对待代码抽象 针对序列化数据使用精简版-protobuf 避免内存抖动 移除会占用大量内存的资源和库 缩减总体 apk大小 使用-dagger-2-实现依赖注入 谨慎使用外部库 减少bitmap占用的内存 防止bitmap占用资源多大导致OOM 图片按需加载 统一的bitmap加载器 图片存..." }, { "title": "Android崩溃优化", "url": "/posts/android-crash-performance/", "categories": "", "tags": "Android", "date": "2019-03-05 10:08:28 +0800", "snippet": "Android的两种崩溃Android崩溃分为Java崩溃和Native崩溃。Java崩溃就是在Java代码中，出现了未捕获异常，导致程序异常退出。Native崩溃一般都是因为在Native代码中访问非法地址，也可能是地址对齐出现的问题，或者发生了程序主动abort，这些都会产生相应的signal信号，导致程序异常退出。1.Native崩溃的捕获流程2.Native崩溃捕获的难点3.选择合适的崩溃服务 腾讯Bugly UC啄木鸟 网易云捕 Google Firbase崩溃现场1.崩溃信息2.系统信息3.内存信息4.资源信息崩溃分析第一步：确定重点1.确认严重程度2.崩溃基本信息3..." }, { "title": "Container详解", "url": "/posts/flutter-widget-container/", "categories": "", "tags": "", "date": "2019-02-19 14:21:37 +0800", "snippet": "Container是一个拥有绘制、定位、调整大小的widget。padding和marginpadding和margin分别设置Container的内边距和外边距。可取值包括下面四个： EdgeInsets.all(50)：设置所有的padding为同一个值50。 EdgeInsets.only(left: 50,right: 50)：只设置左边和右边。 EdgeInsets.fromLTRB(50,10,50,10)：分别设置左上右下的值为50、10。 EdgeInsets.symmetric(vertical: 10,horizontal: 50)：如果上下或者左右的padd..." }, { "title": "关于自我提升的思考", "url": "/posts/up/", "categories": "", "tags": "", "date": "2019-01-05 09:54:09 +0800", "snippet": "从12年算起，自己也在软件开发这个行业已经近7年。自己也一直在从事Android移动开发。回顾自己的这7年，对自己是非常失望的。自己一直从事着应用层的开发，只是一些系统API和第三方库的调用。对于一些高深的Android知识，比如Android安全、Android内核源码并不熟悉。回顾自己这7年，自己也规划过自己的学习路线，但是常常因为一些知识用到的非常少，学了忘，忘了学。还有些时候还特别浮躁，对于一些学习路线陡峭的知识（比如热更新热修复、NDK、源码学习等等）总是会对自己说，开发也用不到，没必要学了。针对自己这些问题，自己也反思过，也总结过应对方案。具体方案如下： 整理自己的知识体系..." }, { "title": "Android运行时权限", "url": "/posts/runtime-permissions/", "categories": "", "tags": "Android", "date": "2018-12-25 04:25:35 +0800", "snippet": "权限的作用是保护 Android 用户的隐私。Android 应用必须请求权限才能访问敏感的用户数据（例如联系人和短信）以及某些系统功能（例如相机和互联网）。系统可能会自动授予权限，也可能会提示用户批准请求，具体取决于访问的功能。Android 安全架构的设计主旨是：在默认情况下，任何应用都没有权限执行会对其他应用、操作系统或用户带来不利影响的任何操作。这包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用的文件、执行网络访问、使设备保持唤醒状态等。权限审批应用必须通过在应用清单中添加 &amp;lt;uses-permission&amp;gt; 标记来公开所需的权..." }, { "title": "安装Flutter", "url": "/posts/flutter-install/", "categories": "", "tags": "", "date": "2018-12-18 13:37:22 +0800", "snippet": "1.安装SDK 官网下载其最新可用的安装包并解压。 设置环境变量 在.bash_profile文件中写入export PATH=/Users/malk/Documents/flutter/bin:$PATH，然后保存并执行source .bash_profile。 运行flutter doctor命令查看是否需要安装其它依赖项来完成安装该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。2.配置Android Studio需要安装两个插件: Flutter插件： 支持Flutter开发工作流 (..." }, { "title": "《Kotlin实战》读书笔记 第8章 Lambda作为形参和返回值", "url": "/posts/kotlin-in-action-chapter8/", "categories": "", "tags": "Kotlin", "date": "2018-09-12 20:26:55 +0800", "snippet": "8.1 声明高阶函数高阶函数就是以另一个函数作为参数或者返回值的函数。8.1.1 函数类型 val sum = { x: Int, y: Int -&amp;gt; x + y } val action = { println(42)} run { println(sum(1,2)) //3 } run{ action() //42 }val sum: (Int, Int) -&amp;gt; Int = { x, y -&amp;gt; x + y } // 有两个Int型参数和Int型返回值的函数val action: ..." }, { "title": "《Kotlin实战》第7章 运算符重载及其他约定", "url": "/posts/kotlin-in-action-chapter7/", "categories": "", "tags": "Kotlin", "date": "2018-09-09 20:26:55 +0800", "snippet": "7.1 重载算术运算符7.1.1 重载二元算术运算data class Point(val x: Int, val y: Int) { operator fun plus(other: Point): Point { return Point(x + other.x, y + other.y) }}val p1 = Point(10, 20)val p2 = Point(30, 40)println(p1 + p2) //Point(x=40, y=60)operator fun Point.plus(other: Point): Point { retu..." }, { "title": "《Kotlin实战》第6章 Kotlin的类型系统", "url": "/posts/kotlin-in-action-chapter6/", "categories": "", "tags": "Kotlin", "date": "2018-09-06 20:26:55 +0800", "snippet": "6.1 可空性6.1.1 可空类型//增加了null检查后，这段代码就可以编译了fun strLenSafe(s: String?) = if (s != null) s.length else 06.1.2 类型的含义6.1.3 安全调用运算符安全调用运算符?允许把一次null检查和一次方法调用合并成一个操作。fun strLenSafe(s: String?) = s?.lengthprintln(strLenSafe(null)) //null6.1.4 Elvis运算符Elvis运算符接收两个运算数，如果第一个运算数不为null，运算结果就是第一个运算数；如果第一个运算数为nul..." }, { "title": "《Kotlin实战》第5章 Lambda编程", "url": "/posts/kotlin-in-action-chapter5/", "categories": "", "tags": "Kotlin", "date": "2018-09-04 20:26:55 +0800", "snippet": "5.1 Lambda表达式和成员引用5.1.1 Lambda简介：作为函数参数的代码块button.setOnClickLisener(new OnClickListener(){ @Override public void onClick(View view){ //点击后执行的动作 }}button.setOnClickListener(/*点击后执行的动作*/)5.1.2 Lambda和集合data class Person(val name:String,val age:Int)fun findTheOldest(people:List&amp;l..." }, { "title": "Kotlin实现单例", "url": "/posts/kotlin-singletone/", "categories": "", "tags": "Kotlin", "date": "2018-08-28 20:26:55 +0800", "snippet": "饿汉式//java实现public class Singleton { private static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; }}//kotlin实现object Singleton//反编译上面的代码 Tools-&amp;gt;Kotlin-&amp;gt;Show Kotlin Bytecodepublic final class Sing..." }, { "title": "《Kotlin实战》第4章 类对象和接口", "url": "/posts/kotlin-in-action-chapter4/", "categories": "", "tags": "Kotlin", "date": "2018-08-28 20:26:55 +0800", "snippet": "4.1 定义类继承结构4.1.1 Kotlin中的接口//接口定义interface Clickable { fun click()}//实现接口class Button:Clickable{ override fun click() = println(&quot;I was clicked&quot;)}接口的方法可以有一个默认实现。interface Clickable { fun click() fun showOff() = println(&quot;I&#39;m clickable!&quot;) //带默认实现的方法}假设存在同样定义了一个sho..." }, { "title": "《Kotlin实战》读书笔记 第3章 函数的定义与调用", "url": "/posts/kotlin-in-action-chapter3/", "categories": "", "tags": "Kotlin", "date": "2018-08-25 20:26:55 +0800", "snippet": "3.1 在kotlin中创建集合val set = hashSetOf(1, 7, 53)val list = arrayListOf(1, 7, 53)val map = hashMapOf(1 to &quot;one&quot;, 7 to &quot;seven&quot;, 53 to &quot;fifty-three&quot;)//kotlin的javaClass等价于Java的getClass()println(set.javaClass) //class java.util.HashSetprintln(list.javaClass) //class java.ut..." }, { "title": "kotlin基础", "url": "/posts/kotlin-basic/", "categories": "", "tags": "Kotlin", "date": "2018-08-25 20:26:55 +0800", "snippet": "2.1 基础要素：函数和变量2.1.1 Hello,world!fun main(args: Array&amp;lt;String&amp;gt;) { println(&quot;Hello, world!&quot;)}2.1.2 函数fun main(args: Array&amp;lt;String&amp;gt;) { println(max(1,2))}fun max(a:Int,b:Int):Int{ return if(a&amp;gt;b) a else b}表达式函数体函数体由单个表达式构成的，可以用这个表达式作为完整的函数体，并去掉花括号和ret..." }, { "title": "Paging 库概述", "url": "/posts/paging-library-overview/", "categories": "", "tags": "", "date": "2018-07-27 22:44:49 +0800", "snippet": "分页库可帮助您一次加载和显示小块数据。按需加载部分数据可减少网络带宽和系统资源的使用。在应用程序或模块的build.gradle文件中添加所需的依赖项：dependencies { def paging_version = &quot;2.1.0&quot; implementation &quot;androidx.paging:paging-runtime:$paging_version&quot; // For Kotlin use paging-runtime-ktx // alternatively - without Android dependencies..." }, { "title": "Kotlin作用域函数", "url": "/posts/kotlin-scope-functions/", "categories": "", "tags": "Kotlin", "date": "2018-07-27 15:05:51 +0800", "snippet": "Kotlin标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。当对一个对象调用这样的函数并提供一个lambda表达式时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。共有以下五种：let、run、with、apply 以及also。这些函数基本上做了同样的事情：在一个对象上执行一个代码块。不同的是这个对象在块中如何使用，以及整个表达式的结果是什么。由于作用域函数本质上都非常相似，因此了解它们之间的区别很重要。每个作用域函数之间有两个主要区别： 引用上下文对象的方式 返回值 函数 对象引用 ..." }, { "title": "Kotlin函数", "url": "/posts/kotlin-functions/", "categories": "", "tags": "Kotlin", "date": "2018-07-27 15:05:51 +0800", "snippet": "函数声明Kotlin中的函数使用fun关键字声明：fun double(x: Int): Int { return 2 * x}函数调用调用函数使用传统的方法：val result = double(2)调用成员函数使用点表示法：Stream().read() // 创建类 Stream 实例并调用 read()参数函数参数使用Pascal表示法定义，即 name: type。参数用逗号隔开。每个参数必须有显式类型：fun powerOf(number: Int, exponent: Int) { /*……*/ }默认参数函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语..." }, { "title": "Dagger2在Android中的使用", "url": "/posts/dagger-android/", "categories": "", "tags": "Dagger", "date": "2018-07-25 11:56:12 +0800", "snippet": " 原文与其他大多数依赖注入框架相比，Dagger2的主要优点之一是其严格生成的实现（无反射）意味着它可以在Android应用程序中使用。但是，在Android应用程序中使用Dagger时仍有一些注意事项。为什么Android上的Dagger很难使用Dagger编写Android应用程序的主要困难之一是很多Android框架类都是由操作系统本身实例化的，例如Activity和Fragment，但是如果Dagger可以创建所有注入的对象，则Dagger的效果最好。相反，您必须在生命周期方法中执行成员注入。这意味着许多类最终看起来像：public class FrombulationActi..." }, { "title": "实现navigation", "url": "/posts/navigation-implementing/", "categories": "", "tags": "", "date": "2018-06-08 00:13:46 +0800", "snippet": "导航体系结构组件简化了应用程序中目标之间导航的实现。目的地是应用中的特定屏幕。默认情况下，导航体系结构组件包括支持fragment和activity作为目标，但您也可以添加对新类型目标的支持。一组目的地组成一个应用程序的“导航图”。除目的地之外，导航图在目标之间具有称为“操作”的连接。图1显示了包含6个目的地的示例应用程序的导航图的直观表示，该应用程序由5个操作连接。在项目中设置navigation在您创建导航图之前，您必须为您的项目设置导航结构组件。要在Android Studio中设置您的项目，请执行以下步骤。 将navigation组件添加到您的应用程序或模块的build.gra..." }, { "title": "LiveData概述", "url": "/posts/livedata-overview/", "categories": "", "tags": "", "date": "2018-05-19 00:47:47 +0800", "snippet": "LiveData是一个可观察的数据持有者类。与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如activity，fragment或service）的生命周期。 这确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。LiveData作为一个用Observer类表示观察者，如果它的生命周期处于STARTED或RESUMED状态，则处于活动状态。LiveData仅通知活动状态的观察者更新。 非活动观察者注册观察LiveData对象不会收到有关更改的通知。您可以注册与实现LifecycleOwner接口的对象配对的观察者。此关系允许在相..." }, { "title": "mat", "url": "/posts/mat/", "categories": "", "tags": "", "date": "2018-01-05 02:13:54 +0800", "snippet": "打开Mat中的Bitmap原图在使用MAT查看应用程序内存使用情况的时候,我们经常会碰到Bitmap对象以及BitmapDrawable$BitmapState对象,而且在内存使用上,Bitmap所占用的内存占大多数.在这样的情况下, Bitmap所造成的内存泄露尤其严重, 需要及时发现并且及时处理.在这样的需求下, 当我们在MAT中发现和图片相关的内存泄露的时候, 如果能知道是那一张图片,对分析问题会有很大的帮助.在MAT中打开Dominator Tree视图 , 选择一个Bitmap对象：查看Inspector窗口,内容如下图：mBuffer的值保存的是图片的二进制数据。mHeigh..." }, { "title": "常用Linux命令", "url": "/posts/linux-command/", "categories": "", "tags": "", "date": "2017-11-07 19:03:08 +0800", "snippet": "mv命令mv命令是move的缩写，可以用来移动文件或者将文件改名。-b ：若需覆盖文件，则覆盖前先行备份。 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新(update)。#将Document中的test目录移动到Downloads目录下mv -f test ../Downloads参考 每天一个linux命令（7）：mv命令 shell script 读取properties 文件http://blog.csdn...." }, { "title": "MultiType和AdapterDelegates源码分析", "url": "/posts/multitype-and-AdapterDelegates-source-analysis/", "categories": "", "tags": "", "date": "2017-11-03 17:03:48 +0800", "snippet": "MultiType和AdapterDelegates两个库都是对RecyclerView的Adapter进行封装的库，可以快速实现多种布局类型的RecyclerView。两个库的核心思想都是封装一个实体我们暂时命名为ItemViewBinder，用来提供布局资源和绑定数据。对于多种类型的Adapter存在多个ItemViewBinder对象，如AItemViewBinder、BItemViewBinder，我们可以使用一个集合来存放这些ItemViewBinder此外，还需要建立viewtype和绑定实体之间的一一对应关系，在onCreateViewHolder和onBindViewHo..." }, { "title": "签署Android应用", "url": "/posts/signing-android-app/", "categories": "", "tags": "", "date": "2017-10-13 00:20:06 +0800", "snippet": "Android 要求所有 APK 必须先使用证书进行数字签署，然后才能安装。从命令行构建和签署您的应用1.使用keytool生成一个私钥使用以下命令可以创建一个有效期为10000天的密钥：keytool -genkeypair -keyalg RSA -keysize 2048 -sigalg SHA1withRSA -validity 10000 -alias test -keystore test.keystore通常我们在申请第三方分享Key时，例如微信和微博需要填写一个签名，这里的签名就是keystore的MD5值。除了使用他们提供的获取签名工具之外，还可以通过如下命令获取key..." }, { "title": "Kotlin 高阶函数和lambda表达式", "url": "/posts/kotlin-lambda-md/", "categories": "", "tags": "Kotlin", "date": "2017-08-02 21:47:12 +0800", "snippet": "高阶函数高阶函数是将函数用作参数或返回值的函数。 这种函数的一个很好的例子是 lock()，它接受一个锁对象和一个函数，获取锁，运行函数并释放锁：fun &amp;lt;T&amp;gt; lock(lock: Lock, body: () -&amp;gt; T): T { lock.lock() try { return body() } finally { lock.unlock() }}body 拥有函数类型：() -&amp;gt; T， 所以它应该是一个不带参数并且返回 T 类型值的函数。 它在 try代码块内部调用、..." }, { "title": "Retrofit源码分析", "url": "/posts/retrofit-source-analysis/", "categories": "", "tags": "源码分析", "date": "2017-07-26 04:07:22 +0800", "snippet": "Retrofit源码分析流程分析Retrofit执行流程可以分为两部分： 创建ServiceMethod。 调用ServiceMethod的invoke()。下图中，黑线部分是创建ServiceMethod的过程，红线部分是invoke()的调用过程。ServiceMethod创建过程： 通过动态代理，获取到我们定义的接口里的所有Method，调用ServiceMethod的静态方法parseAnnotations创建ServiceMethod。 ServiceMethod调用RequestFactory的静态方法parseAnnotations创建RequestFactory。..." }, { "title": "生成绑定类", "url": "/posts/generated-binding-classes/", "categories": "", "tags": "android, databinding", "date": "2017-06-19 20:01:58 +0800", "snippet": "数据绑定库生成用于访问布局的变量和视图的绑定类。生成的绑定类将布局变量与布局中的视图链接起来。绑定类的名称和包可以自定义。所有生成的绑定类都继承自ViewDataBinding类。为每个布局文件生成绑定类。默认情况下，类的名称基于布局文件的名称，将其转换为Pascal大小写并向其添加Binding后缀。布局文件名是activity_main.xml，因此相应的生成类是ActivityMainBinding。此类包含布局属性（例如，用户变量）到布局视图的所有绑定，并知道如何为绑定表达式指定值。创建一个绑定对象在对布局进行inflate之后，应该很快创建绑定对象，以确保在使用布局中的表达式绑..." }, { "title": "绑定适配器使用", "url": "/posts/binding-adapters/", "categories": "", "tags": "android, databinding", "date": "2017-06-13 18:14:02 +0800", "snippet": "绑定适配器负责对设置值进行适当的框架调用。一个例子是设置一个属性值，如调用setText()方法。另一个例子是设置一个事件监听器，如调用setOnClickListener()方法。数据绑定库允许您指定调用的方法来设置值，提供自己的绑定逻辑，并使用适配器指定返回对象的类型。设置属性值每当绑定值发生更改时，生成的绑定类必须使用绑定表达式在视图上调用setter方法。您可以允许数据绑定库自动确定方法，显式声明方法或提供自定义逻辑来选择方法。自动方法选择对于名为example的属性，库自动尝试查找接受兼容类型作为参数的方法setExample(arg)。不考虑属性的命名空间，搜索方法时仅使用属..." }, { "title": "DataBinding绑定表达式使用", "url": "/posts/binding-expressions/", "categories": "", "tags": "android, databinding", "date": "2017-06-11 18:14:02 +0800", "snippet": "表达式语言允许您编写处理View分发的事件的表达式。数据绑定库自动生成将布局中的View与数据对象绑定所需的类。数据绑定布局文件略有不同，以layout根标签开头，后跟data元素和view根元素。此view元素是您的根在非绑定布局文件中的位置。以下代码显示了一个示例布局文件：&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&am..." }, { "title": "Android自定义属性", "url": "/posts/android-custom-attribute/", "categories": "", "tags": "", "date": "2017-03-22 01:37:26 +0800", "snippet": "创建自定义属性需要以下步骤： 创建一个自定义View。 创建values/attrs.xml文件，并定义属性。 在View中获取属性值并使用。自定义属性&amp;lt;resources&amp;gt; &amp;lt;declare-styleable name=&quot;PieChart&quot;&amp;gt; &amp;lt;attr name=&quot;showText&quot; format=&quot;boolean&quot; /&amp;gt; &amp;lt;attr name=&quot;labelPosition&quot..." }, { "title": "Git使用", "url": "/posts/git-usage/", "categories": "", "tags": "Git", "date": "2016-11-25 19:22:54 +0800", "snippet": "git remotegit remote add origin git@gitee.com:malinkang/learngit.git #添加远程仓库git remote remove origin #删除远程仓库git remote -v #查看远程仓库地址分支git checkout -b v2.0.0 #创建分支git checkout v1.0.0 #切换分支git merge v1.0.0 #合并分支git branch -d v1.0.0 #删除分支git push origin --delete v2.0.0 #删除远程分支git branch #查看分支git bran..." }, { "title": "《深入理解JVM》第13章线程安全和锁优化", "url": "/posts/understanding-the-jvm-thread-safe-and-lock-optimization/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-09-24 17:09:28 +0800", "snippet": "13.3 锁优化高效并发是从JDK 1.5到JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（AdaptiveSpinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。13.3.1 自旋锁与自适应自旋前面我们讨论互斥同步的时候，提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操..." }, { "title": "《深入理解JVM》第12章内存模型与线程", "url": "/posts/understanding-the-jvm-java-memory-model-and-thread/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-09-17 17:09:28 +0800", "snippet": "" }, { "title": "《深入理解JVM》第10章编译期优化", "url": "/posts/understanding-the-jvm-compilation-optimization/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-09-10 17:09:28 +0800", "snippet": "第10章 Java内存区域与内存溢出10.1 概述10.2 Javac编译器10.2.1 Javac的源码与调试从Sun Javac的代码来看，编译过程大致可以分为3个过程，分别是： 解析与填充符号表过程。 插入式注解处理器的注解处理过程。 ￼ 分析与字节码生成过程。这3个步骤之间的关系与交互顺序如图10-4所示。Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法中，其中主体代码如图10-5所示，整个编译最关键的处理就由图中标注的8个方法来完成，下面..." }, { "title": "《深入理解JVM》第8章虚拟机字节码执行引擎", "url": "/posts/understanding-the-jvm-execution-engine/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-09-03 21:39:36 +0800", "snippet": "" }, { "title": "《深入理解JVM》第7章虚拟机类加载机制", "url": "/posts/understanding-the-jvm-class-loader/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-08-27 21:39:36 +0800", "snippet": "类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。什么情况下..." }, { "title": "《深入理解JVM》第6章类文件结构", "url": "/posts/understanding-the-jvm-class-file-structure/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-08-20 21:39:36 +0800", "snippet": "Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表： 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、..." }, { "title": "《深入理解JVM》第3章垃圾收集器", "url": "/posts/understanding-the-jvm-garbage-collection/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-08-13 21:39:36 +0800", "snippet": "垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”了。判断是对象是否应该被回收引用计数算法引用计数算法（Reference Counting）就是对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 优点：原理简单，判定效率也很高。 缺点：很难解决对象之间相互循环引用的问题。 可达性分析算法可达性分析（Reachability Analysis）的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始..." }, { "title": "《深入理解JVM》第2章Java内存区域与内存溢出异常", "url": "/posts/understanding-the-jvm-runtime-data-areas/", "categories": "Java, JVM", "tags": "深入理解JVM", "date": "2016-08-06 21:39:36 +0800", "snippet": "运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示。程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序..." }, { "title": "Dagger使用指南", "url": "/posts/dagger-guide/", "categories": "", "tags": "Dagger", "date": "2016-07-25 09:47:31 +0800", "snippet": "任何应用程序中最好的类是那些做事情的类：BarcodeDecoder，KoopaPhysicsEngine和AudioStreamer。 这些类具有依赖性; 也许是一个BarcodeCameraFinder，DefaultPhysicsEngine和一个HttpStreamer。相比之下，任何应用程序中最糟糕的类是那些占用空间而又没有做太多事情类：BarcodeDecoderFactory，CameraServiceLoader和MutableContextWrapper。 这些类是将有趣的东西连接在一起。Dagger是这些FactoryFactory类的替代品，它们实现了依赖注入设计模..." }, { "title": "Java线程池", "url": "/posts/java-threadpool/", "categories": "", "tags": "", "date": "2016-07-15 18:24:54 +0800", "snippet": "线程池介绍合理利用线程池能够带来三个好处： 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。Java通过Executors提供四种线程池: newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFix..." }, { "title": "Android Bitmap使用", "url": "/posts/android-bitmap/", "categories": "", "tags": "", "date": "2016-06-24 21:52:35 +0800", "snippet": "Bitmap占用内存计算Android的Bitmap对象提供了方法getByteCount来获取Bitmap的字节数。 public final int getByteCount() { // int result permits bitmaps up to 46,340 x 46,340 return getRowBytes() * getHeight(); }getRowBytes()方法用来获取每行的字节数，内部调用一个native方法。 public final int getRowBytes() { if (mRecyc..." }, { "title": "创建 Android Studio Template", "url": "/posts/android-studio-template/", "categories": "", "tags": "", "date": "2016-06-15 18:40:23 +0800", "snippet": "AndroidStudio 为我们提供了很多创建Activity以及其他类和文件夹的Template。AndroidStudio虽然提供了大多常见的的模板，但是不可能满足每个人的需求，因此自定义模板就显得很有必要。下面我们将分析系统提供的模板，并自己来实现模板。系统提供的Template存放在/Applications/Android Studio.app/Contents/plugins/android/lib/templates目录下，activities目录下是Actiivty模板。下面我们以EmptyActivity为例进行分析template.xml 代码如下：&amp;lt;..." }, { "title": "自定义Okhttp拦截器", "url": "/posts/okhttp-interceptors/", "categories": "", "tags": "", "date": "2016-04-18 11:06:21 +0800", "snippet": "Okhttp提供拦截器来对请求进行拦截做自己想要的一些操作，比如官方提供的okhttp-logging-interceptor拦截请求打印请求和返回的数据的日志。有时候我们的每个请求都要求添加公共参数或者对每个接口进行加密，采用拦截器可以进行统一处理。添加公共参数class CommonParametersInterceptor : Interceptor { override fun intercept(chain: Interceptor.Chain): Response { val request = chain.request() //获取request ..." }, { "title": "《Effective Java》第12章序列化", "url": "/posts/effective-java-serialization/", "categories": "", "tags": "Effective Java", "date": "2016-03-12 17:02:08 +0800", "snippet": "对象序列化（object serialization）API，提供了一个框架，用来将对象编码成字节流，并从字节流编码中重新构建对象。“将一个对象编码成一个字节流”，称作将该对象序列化（serializing）；相反的处理过程被称作反序列化（deserializing）。一旦对象被序列化后，它的编码就可以从一台正在运行的虚拟机被传递到另一台虚拟机上，或者被存储到磁盘上，供以后反序列化使用。第74条：谨慎地实现Serializable接口要想使一个类的实例可被序列化，非常简单，只要在它的声明中加入“implements Serializable”字样即可。正因为太容易了，所以普遍存在这样一种..." }, { "title": "《Effective Java》第11章并发", "url": "/posts/effective-java-concurrency/", "categories": "", "tags": "Effective Java", "date": "2016-03-05 17:02:08 +0800", "snippet": "" }, { "title": "《算法》读书笔记 第3章 查找", "url": "/posts/algorithms-4th-edition-chapter3/", "categories": "", "tags": "算法, 读书笔记", "date": "2016-03-01 14:33:57 +0800", "snippet": "3.1 符号表3.1.1 API3.1.2 有序符号表3.1.3 用例举例3.1.4 无序链表中的顺序查找3.1.5 有序数组中的二分查找import edu.princeton.cs.algs4.BinarySearch;/** * Created by malk on 2018/12/25. */public class BinarySearchST&amp;lt;Key extends Comparable&amp;lt;Key&amp;gt;, Value&amp;gt; { private Key[] keys; private Value[] values; ..." }, { "title": "React Native for Android 入门", "url": "/posts/react-native-1/", "categories": "Program", "tags": "", "date": "2016-02-29 17:38:05 +0800", "snippet": "环境配置 安装Homebrew：Homebrew是Mac的一个包管理器。 安装Node.js 通过nvm安装Node.js nvm是Node.js的版本管理器，首先安装使用Homebrew安装nvm brew install nvm 配置nvm mkdir ~/.nvm export NVM_DIR=~/.nvm. $(brew --prefix nvm)/nvm.sh 安装nodejs nvm install node 安装Node.js的同时也安装了n..." }, { "title": "《Effective Java》第10章异常", "url": "/posts/effective-java-exceptions/", "categories": "", "tags": "Effective Java", "date": "2016-02-27 17:02:08 +0800", "snippet": "" }, { "title": "《Effective Java》第9章通用程序设计", "url": "/posts/effective-java-general-programming/", "categories": "", "tags": "Effective Java", "date": "2016-02-20 17:02:08 +0800", "snippet": "第45条：将局部变量的作用域最小化要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。循环中提供了特殊的机会来将变量的作用域最小化。for循环，都允许声明循环变量（loop variable），它们的作用域被限定在正好需要的范围之内。因此，如果在循环终止之后不再需要循环变量的内容，for循环就优于while循环。Iterator&amp;lt;Element&amp;gt; i = c.iterator();while(i.hasNext()){ doSomething(i.next());}Iterator&amp;lt;Element&amp;gt; i2 =..." }, { "title": "《Effective Java》第8章方法", "url": "/posts/effective-java-methods/", "categories": "", "tags": "Effective Java", "date": "2016-02-13 17:02:08 +0800", "snippet": "第38条：检查参数的有效性对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值会抛出的异常。一旦在文档中记录了对于方法参数的限制，并且记录了一旦违反这些限制将要抛出的异常，强加这些限制就是非常简单的事情了。 /** * Returns a {@code BigInteger} whose value is {@code this mod m}. The * modulus {@code m} must be positive. The result is guaranteed to be in the * interval {@code [..." }, { "title": "《Effective Java》第7章lambda表达式和流", "url": "/posts/effective-java-lambdas-and-streams/", "categories": "", "tags": "Effective Java", "date": "2016-02-06 17:02:08 +0800", "snippet": "" }, { "title": "《Effective Java》第6章枚举和注解", "url": "/posts/effective-java-enums-and-annotations/", "categories": "", "tags": "Effective Java", "date": "2016-01-31 01:35:20 +0800", "snippet": "第30条：用enum代替int常量在编程语言中还没有引入枚举类型之前，表示枚举类型的常量模式是声明一组具名的int常量，每个类型成员一个常量：public static final int APPLE_FUJI = 0;public static final int APPLE_PIPPIN = 1;public static final int APPLE_GRANNY_SMITH = 2;public static final int ORANGE_NAVEL = 0;public static final int ORANGE_TEMPLE = 1;public static fi..." }, { "title": "《Effective Java》第5章泛型", "url": "/posts/effective-java-generics/", "categories": "", "tags": "Effective Java", "date": "2016-01-24 01:34:59 +0800", "snippet": "第26条：请不要在新代码中使用原生态类型声明中具有一个或者多个类型参数（type parameter）的类或者接口就是泛型类或者接口。泛型类和接口统称为泛型（generic type）。每种泛型定义一组参数化的类型（parameterized type），构成格式为：先是类或者接口的名称，接着用尖括号（&amp;lt;&amp;gt;）把对应于泛型形式类型参数的实际类型参数列表括起来。每个泛型都定义一个原生态类型（raw type），即不带任何实际类型参数的泛型名称。例如，与List&amp;lt;E&amp;gt;相对应的原生态类型是List。原生态类型就像从类型声明中删除了所有泛型信..." }, { "title": "《Effective Java》第4章类和接口", "url": "/posts/effective-java-classes-and-interfaces/", "categories": "Java", "tags": "Effective Java", "date": "2016-01-17 01:34:17 +0800", "snippet": "第13条：使类和成员的可访问性最小化区分一个组件设计得好不好，唯一重要的因素在于，它对于外部的其他组件而言，是否隐藏了其内部数据和其他实现细节。 设计良好的组件会隐藏所有的实现细节， 把 API与实现清晰地隔离开来。 然后，组件之间只通过API进行通信，一个模块不需要知道其他模块的内部工作情况。 这个概念被称为信息隐藏( info1mation hiding)或封装( encapsulation), 是软件设计的基本原则之一。Java程序设计语言提供了许多机制来协助信息隐藏。访问控制（access control)机制决定了类、接口和成员的可访问性（accessibility）。实体的可..." }, { "title": "《Effective Java》第3章对于所有对象都通用的方法", "url": "/posts/effective-java-methods-common-to-all-objects/", "categories": "", "tags": "Effective Java", "date": "2016-01-09 23:18:19 +0800", "snippet": "第8条：覆盖equals时请遵守通用约定在覆盖equals方法的时候，你必须要遵守它的通用约定。 自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。 对称性（symmetric)。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。 传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。 一致性（consistent）。对..." }, { "title": "《Effective Java》第2章创建和销毁对象", "url": "/posts/effective-java-creating-and-destroying-objects/", "categories": "", "tags": "Effective Java", "date": "2016-01-02 22:18:11 +0800", "snippet": "第1条：考虑用静态工厂方法替代构造器创建类实例最常用的方法就是提供一个公有的构造器。此外，还可以提供一个公有的静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。//来自Boolean的简单示例//这个方法将boolean基本类型值转换成了一个Boolean对象引用：public static Boolean valueOf(boolean b) { return b ? TRUE : FALSE;}静态工厂方法与构造器不同的第一大优势在于，它们有名称。静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。这使..." }, { "title": "Android Canvas", "url": "/posts/android-canvas/", "categories": "", "tags": "", "date": "2015-12-22 21:38:02 +0800", "snippet": "Canvas我们可以称之为画布，我们可以使用画笔在上面绘制颜色，也可以绘制点、线以及矩形、扇形等各种形状，还可以绘制图片文本路径等，下面我们一一进行介绍绘制颜色Canvas提供了三个绘制颜色的方法。 drawColor drawRGB drawARGB绘制基本形状想要在画布上进行绘制，就需要一个画笔Paint。这里我们只简单介绍画笔的使用，关于画笔的详细使用将在画笔这一章详细介绍。public class CanvasView extends View { public CanvasView(Context context, @Nullable AttributeSet attr..." }, { "title": "android反编译", "url": "/posts/android-decompile/", "categories": "", "tags": "", "date": "2015-12-07 15:48:40 +0800", "snippet": "ApktoolApktool 能够从APK中解析出资源文件，xml文件以及生成smail文件。mac系统下Apktool安装步骤： 打开终端进入 /usr/local/bin目录下执行命令touch apktool创建apktool文件。 copy脚本到apktool。 下载最新的jar，修改名字为apktool.jar并放到/usr/local/bin目录下。 执行命令 chmod +x /usr/local/bin/apktoolapktool使用：切换到apk所在目录下执行apktool d test.apk命令对apk进行反编译。dex2jardex2jar可以将APK中..." }, { "title": "《Java并发编程实战》第16章Java内存模型", "url": "/posts/java-currency-in-practice-the-java-momory-model/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-11-19 18:53:22 +0800", "snippet": "本章将介绍Java内存模型的底层需求以及锁提供的保证，此外还将介绍在本书给出的一些高层设计原则背后的原理。16.1 什么是内存模型，为什么需要它16.1.1 平台的内存模型16.1.2 重排序16.1.3 Java内存模型简介16.1.4 借助同步16.2 发布16.2.1 不安全的发布16.2.2 安全的发布16.2.3 安全初始化模式16.2.4 双重检查加锁双重校验锁写法public class Singleton { private static volatile Singleton singleton; private Singleton() { } p..." }, { "title": "《Java并发编程实战》第15章原子变量与非阻塞同步机制", "url": "/posts/java-currency-in-practice-atomic-variables-and-nonblocking-synchronization/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-11-12 18:53:22 +0800", "snippet": "在java.util.concurrent包的许多类中，例如Semaphore和ConcurrentLinkedQueue，都提供了比synchronized机制更高的性能和可伸缩性。15.1 锁的劣势15.2 硬件对并发的支持15.2.1 比较并交换15.2.2 非阻塞的计数器15.2.3 JVM对CAS的支持15.3 原子变量类共有12个原子变量类，可分为4组：标量类（Scalar）、更新器类、数组类以及复合变量类。最常用的原子变量就是标量类：AtomicInteger、AtomicLong、AtomicBoolean以及AtomicReference。所有这些类都支持CAS，此外，..." }, { "title": "《Java并发编程实战》第14章构建自定义的同步工具", "url": "/posts/java-currency-in-practice-building-custom-synchronizers/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-11-05 18:53:22 +0800", "snippet": "类库包含了许多存在状态依赖性的类，例如FutureTask、Semaphore和BlockingQueue等。在这些类的一些操作中有着基于状态的前提条件，例如，不能从一个空的队列中删除元素，或者获取一个尚未结束的任务的计算结果，在这些操作可以执行之前，必须等到队列进入“非空”状态，或者任务进入“已完成”状态。创建状态依赖类的最简单方法通常是在类库中现有状态依赖类的基础上进行构造。如果类库没有提供你需要的功能，那么还可以使用Java语言和类库提供的底层机制来构造自己的同步机制，包括内置的条件队列、显式的Condition对象以及AbstractQueuedSynchronizer框架。14..." }, { "title": "《Java并发编程实战》第13章显式锁", "url": "/posts/java-currency-in-practice-explicit-locks/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-10-29 18:53:22 +0800", "snippet": "在Java 5.0之前，在协调对共享对象的访问时可以使用的机制只有synchronized和volatile。Java5.0增加了一种新的机制：ReentrantLock。ReentrantLock并不是一种替代内置锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。13.1 Lock与ReentrantLockLock接口中定义了一组抽象的加锁操作。与内置加锁机制不同的是，Lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的。在Lock的实现中必须提供与内部锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证以及性能特性等方..." }, { "title": "《Java并发编程实战》第8章线程池的使用", "url": "/posts/java-currency-in-practice-applying-thread-pools/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-10-22 18:53:22 +0800", "snippet": "本章将介绍对线程池进行配置与调优的一些高级选项，并分析在使用任务执行框架时需要注意的各种危险，以及一些使用Executor的高级示例。8.1 在任务与执行策略之间的隐性耦合8.2 设置线程池的大小8.3 配置ThreadPoolExecutor8.3.1 线程的创建于销毁8.3.2 管理队列任务ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3种：无界队列、有界队列和同步移交（Synchronous Handoff）。队列的选择与其他的配置参数有关，例如线程池的大小等。newFixedThreadPool和newSing..." }, { "title": "《Java并发编程实战》第6章执行任务", "url": "/posts/java-currency-in-practice-task-execution/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-10-15 18:53:22 +0800", "snippet": "大多数并发应用程序都是围绕“任务执行”来构造的，任务通常是一些抽象的且离散的工作单元。通过把应用程序的工作分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性。6.1 在线程中执行任务6.2 Executor框架6.2.3 线程池“在线程池中执行任务”比“为每个任务分配一个线程”优势更多。通过重用现有的线程而不是创建新的线程，可以在处理多个请求时分摊在创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当调整线程池..." }, { "title": "《Java并发编程实战》第7章取消与关闭", "url": "/posts/java-currency-in-practice-cancellation-and-shutdown/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-10-15 18:53:22 +0800", "snippet": "任务和线程的启动很容易，在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然后，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断（Interruption），这是一种协作机制，能够使一个线程终止另一个线程的当前工作。7.1 任务取消7.2 停止基于线程的服务7.2.2 关闭ExecutorServiceExecutorService提供了两种关闭方法：使用shutdown正常关闭，以及使用shutdownNow强行关闭..." }, { "title": "《Java并发编程实战》第5章基础构建模块", "url": "/posts/java-currency-in-practice-building-blocks/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-10-08 18:53:22 +0800", "snippet": "Java平台类库包含了丰富的并发基础构建模块，例如线程安全的容器类以及各种用于协调多个相互协作的线程控制流的同步工具类（Synchronizer）。本章将介绍其中一些最有用的开发构建模块，特别是在Java5.0和Java6中引入的一些新模块，以及在使用这些模块来构造并发应用程序时的一些常用模式。5.1 同步容器类同步容器类包括Vector和Hashtable，二者都是早期JDK的一部分，此外还包括在JDK1.2中添加的一些功能相似的类，这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公..." }, { "title": "《Java并发编程实战》第3章对象的共享", "url": "/posts/java-currency-in-practice-sharing-objects/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-10-01 18:53:22 +0800", "snippet": "我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字synchronized只能用于实现原子性或者确定临界区。同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情况就无法实现。你可以通过显式的同步或者类库中内置的同步来保证对象被安全地发布。3.1 可见性3.1.1 失效数据3.1.2 非原子的64位操作3.1.3 加锁与可见性3.1.4 Volatile变量J..." }, { "title": "《Java并发编程实战》第2章线程安全性", "url": "/posts/java-currency-in-practice-thread-safety/", "categories": "Java", "tags": "Java并发编程实战", "date": "2015-09-24 18:53:22 +0800", "snippet": "一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要使得对象时线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁（Explicit Lock）以及原子变量。2.1 什么是线程安全性2.1 什么是线程安全性2.2 ..." }, { "title": "ButterKnife源码分析", "url": "/posts/butterknife/", "categories": "", "tags": "", "date": "2015-04-19 18:40:23 +0800", "snippet": "功能介绍在Android中，我们从布局文件中获取一个view一般通过findViewById方法来操作，当一个界面里view过多的时候，我们需要花费大量的时间来写这些样板代码。ButterKnife用于来简化这个操作的，只需要在相应的View上加一个注解，框架就会注入这些字段。基本使用在Activity中使用class ExampleActivity extends Activity { @Bind(R.id.title) TextView title; @Bind(R.id.subtitle) TextView subtitle; @Bind(R.id.footer) TextV..." }, { "title": "Java动态代理", "url": "/posts/java-dynamic-proxy/", "categories": "", "tags": "Java", "date": "2014-11-30 01:36:33 +0800", "snippet": "代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替”实际“对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色。下面是一个用来展示代理结构的简单示例：interface Interface { void doSomething(); void somethingElse(String arg);}//实现Interfaceclass RealObject implements Interface { @Override public void doSomething() { System.out...." }, { "title": "Android Studio常用插件", "url": "/posts/android-studio-plugins/", "categories": "", "tags": "", "date": "2014-06-15 18:40:23 +0800", "snippet": " ButterKnifeZelezny android-parcelable-intellij-plugin GsonFormat android-selector-chapek adb-idea android-material-design-icon-generator-plugin扩展阅读 Android-Studio-Plugins Android Studio有哪些非常好用的插件？" }, { "title": "sqlite常用语法总结", "url": "/posts/sqlite/", "categories": "", "tags": "", "date": "2014-03-27 01:23:24 +0800", "snippet": "1.创建表SQLite数据类型integer：整数值real：浮点数text:文本blob：二进制大对象NULL唯一性约束UNIQUECREATE TABLE Contacts (id INTEGER PRIMARY KEY,name TEXT NOT NULL,phone TEXT NOT NULL DEFAULT &#39;UNKNOWN&#39;,UNIQUE(name,phone));INSERT INTO Contacts (name,phone) values (&#39;Jerry&#39;,&#39;UNKNOWN&#39;);//再次插入会出现错误INSERT INTO..." }, { "title": "HashMap源码分析", "url": "/posts/hashmap/", "categories": "Java, JDK源码分析", "tags": "", "date": "2014-01-18 14:33:57 +0800", "snippet": "类图构造函数public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) ..." }, { "title": "LinkedList源码分析", "url": "/posts/linkedlist/", "categories": "Java, JDK源码分析", "tags": "", "date": "2014-01-11 14:33:57 +0800", "snippet": "类图构造函数transient int size = 0;transient Node&amp;lt;E&amp;gt; first; //记录第一个节点transient Node&amp;lt;E&amp;gt; last; //记录最后一个节点public LinkedList() {}public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) { this(); addAll(c);//调用addAll方法}添加add()public boolean add(E e) { linkLast(e);//调用..." }, { "title": "ArrayList源码分析", "url": "/posts/arraylist/", "categories": "Java, JDK源码分析", "tags": "", "date": "2014-01-04 14:33:57 +0800", "snippet": "类图构造函数private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } el..." }, { "title": "《Java编程思想》第21章并发", "url": "/posts/thinking-in-java-concurrency/", "categories": "", "tags": "Thinking in Java", "date": "2013-07-30 21:39:36 +0800", "snippet": "" }, { "title": "《Java编程思想》第20章注解", "url": "/posts/thinking-in-java-annotations/", "categories": "", "tags": "Thinking in Java", "date": "2013-07-23 21:39:36 +0800", "snippet": "" }, { "title": "《Java编程思想》第19章枚举类型", "url": "/posts/thinking-in-java-enumerated-types/", "categories": "", "tags": "Thinking in Java", "date": "2013-07-16 21:39:36 +0800", "snippet": "19.1 基本enum特性调用enum的values()方法，可以遍历enum实例。values()方法返回enum实例的数组，而且该数组中的元素严格保持其在enum中声明时的顺序。创建enum时，编译器会为你生成一个相关的类，这个类继承自java.lang.Enum。//: enumerated/EnumClass.java// Capabilities of the Enum classimport static net.mindview.util.Print.*;enum Shrubbery { GROUND, CRAWLING, HANGING }public class Enu..." }, { "title": "《Java编程思想》第18章I/O系统", "url": "/posts/thinking-in-java-i-o/", "categories": "", "tags": "Thinking in Java", "date": "2013-07-09 21:39:36 +0800", "snippet": "1.File类1.1 目录列表器//: io/DirList.java// Display a directory listing using regular expressions.// {Args: &quot;D.*\\.java&quot;}import java.util.regex.*;import java.io.*;import java.util.*;public class DirList { public static void main(String[] args) { File path = new File(&quot;.&quot;); Stri..." }, { "title": "《Java编程思想》第17章容器深入研究", "url": "/posts/thinking-in-java-containers-in-depth/", "categories": "Java, Thinking in Java", "tags": "Thinking in Java", "date": "2013-07-02 21:39:36 +0800", "snippet": "填充容器与Arrays版本一样，此fill()方法也是只复制同一个对象引用来填充整个容器的，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法：//: containers/FillingLists.java// The Collections.fill() &amp;amp; Collections.nCopies() methods.import java.util.*;class StringAddress { private String s; public StringAddress(String s) { this.s = s; } pub..." }, { "title": "《Java编程思想》第16章数组", "url": "/posts/thinking-in-java-arrays/", "categories": "Java, Thinking in Java", "tags": "Thinking in Java", "date": "2013-06-25 21:39:36 +0800", "snippet": "数组为什么特殊数组与其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译期检查，来防止插入错误类型和抽取不当类型。数组可以持有基本类型，而泛型之前的容器则不能，但是有了泛型，容器就可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够持有基本类型。public c..." }, { "title": "《Java编程思想》第15章泛型", "url": "/posts/thinking-in-java-generics/", "categories": "", "tags": "Thinking in Java", "date": "2013-06-18 21:39:36 +0800", "snippet": "一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数。这样的方法更加通用一些，可应用的地方也多一些。在类的内部也是如此，凡是需要说明类型的地方，如果都使用基类，确实能够具备更好的灵活性。但是，考虑到除了final类不能扩展，其他任何类都可以被扩展，所以这种灵活性大多数时候也会有一些性能损耗。有时候，拘泥于单继承体系，也会使程序受限太多。如果方法的参数是一个接口，而不是..." }, { "title": "《Java编程思想》第14章类型信息", "url": "/posts/thinking-in-java-type-information/", "categories": "", "tags": "Thinking in Java", "date": "2013-06-11 21:39:36 +0800", "snippet": "运行时类型信息使得可以在程序运行时发现和使用类型信息。它使你从只能在编译期执行面向类型的操作的禁锢中解脱了出来，并且可以使用某些非常强大的程序。对RTTI的需要，揭示了面向对象设计中许多有趣的问题，同时也提出了如何组织程序的问题。Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。14.1 为什么需要RTTIabstract class Shape{ void draw(){ System.out.println(this + &qu..." }, { "title": "《Java编程思想》第13章字符串", "url": "/posts/thinking-in-java-strings/", "categories": "Java, Thinking in Java", "tags": "Thinking in Java", "date": "2013-06-04 21:39:36 +0800", "snippet": "第13章 字符串13.1 不可变Stringpublic class Immutable { public static String upcase(String s){ return s.toUpperCase(); } public static void main(String[] args) { String q = &quot;howdy&quot;; System.out.println(q); String qq = upcase(q); System.out.println(qq); ..." }, { "title": "《Java编程思想》第12章通过异常处理错误", "url": "/posts/thinking-in-java-error-handling-with-exceptions/", "categories": "", "tags": "Thinking in Java", "date": "2013-05-28 21:39:36 +0800", "snippet": "" }, { "title": "《Java编程思想》第11章持有对象", "url": "/posts/thinking-in-java-holding-your-objects/", "categories": "", "tags": "Thinking in Java, 读书笔记", "date": "2013-05-21 21:39:36 +0800", "snippet": "第11章 持有对象1.泛型和类型安全的容器Apple和Orange都放置在了容器中，然后将它们取出。正常情况下，Java编译器会报告警告信息，因为这个示例没有使用泛型。在这里，我们使用Java SE5所特有的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的@SuppressWarnings注解及其参数标识只有有关“不受检查的异常”的警告信息应该被压制。class Apple{ private static long counter; private final long id = counter++; public long id(){ return i..." }, { "title": "《Java编程思想》第10章内部类", "url": "/posts/thinking-in-java-inner-classes/", "categories": "", "tags": "Thinking in Java", "date": "2013-05-14 21:39:36 +0800", "snippet": "1.创建内部类创建内部类的方式就是把类的定义置于外围类的里面。public class Parcel1 { class Contents { private int i = 11; public int value() { return i; } } class Destination { private String label; Destination(String whereTo) { label = whereTo; } ..." }, { "title": "《Java编程思想》第9章接口", "url": "/posts/thinking-in-java-interfaces/", "categories": "", "tags": "Thinking in Java", "date": "2013-05-07 21:39:36 +0800", "snippet": "1.抽象类和抽象方法2.接口3.完全解耦4.Java的多重继承public interface CanFight { void fight();}public interface CanSwim { void swim();}public interface CanFly { void fly();}public class ActionCharacter { public void fight(){}}public class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly { ..." }, { "title": "《Java编程思想》第8章多态", "url": "/posts/thinking-in-java-polymorphism/", "categories": "", "tags": "Thinking in Java", "date": "2013-04-30 21:39:36 +0800", "snippet": "8.1 再论向上转型对某个对象的引用视为对其基类型的引用的做法被称作向上转型。单独创建一个奏乐符（Note）类：//: polymorphism/music/Note.java// Notes to play on musical instruments.package polymorphism.music;public enum Note { MIDDLE_C, C_SHARP, B_FLAT; // Etc.} ///:~乐器类Instrument://: polymorphism/music/Instrument.javapackage polymorphism.music;..." }, { "title": "《Java编程思想》第7章复用类", "url": "/posts/thinking-in-java-reusing-classes/", "categories": "", "tags": "Thinking in Java", "date": "2013-04-23 21:39:36 +0800", "snippet": "7.1 组合语法//: reusing/SprinklerSystem.java// Composition for code reuse.class WaterSource { private String s; WaterSource() { System.out.println(&quot;WaterSource()&quot;); s = &quot;Constructed&quot;; } public String toString() { return s; }} public class SprinklerSystem { private St..." }, { "title": "《Java编程思想》第6章访问权限控制", "url": "/posts/thinking-in-java-access-control/", "categories": "", "tags": "Thinking in Java", "date": "2013-04-16 21:39:36 +0800", "snippet": "" }, { "title": "《Java编程思想》第5章初始化与清理", "url": "/posts/thinking-in-java-initialization-and-cleanup/", "categories": "", "tags": "Thinking in Java", "date": "2013-04-09 21:39:36 +0800", "snippet": "随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。初始化和清理（cleanup）正是涉及安全的两个问题。C++引入了”构造器（constructor）”的概念，这是一个在创建对象时被自动调用的特殊方法。Java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。5.1用构造器确保初始化//: initialization/SimpleConstructor.java// Demonstration of a simple constructor.class Rock { Rock() { // This is the..." }, { "title": "《Java编程思想》第4章控制流程", "url": "/posts/thinking-in-java-controlling-execution/", "categories": "", "tags": "Thinking in Java", "date": "2013-04-02 21:39:36 +0800", "snippet": "" }, { "title": "《Java编程思想》第3章操作符", "url": "/posts/thinking-in-java-operators/", "categories": "", "tags": "Thinking in Java", "date": "2013-03-26 21:39:36 +0800", "snippet": "" }, { "title": "《Java编程思想》第2章一切都是对象", "url": "/posts/thinking-in-java-everything-is-an-object/", "categories": "", "tags": "Thinking in Java", "date": "2013-03-20 00:26:34 +0800", "snippet": "2.2 必须由你创建所有对象2.2.1 存储到什么地方2.2.2 特例：基本类型在程序设计中经常用到一系列类型，它们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象，特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采取与C和C++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于栈中，因此更加高效。Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Jav..." } ]

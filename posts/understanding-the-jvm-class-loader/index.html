<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="《深入理解JVM》第7章虚拟机类加载机制" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="类加载的时机" /><meta property="og:description" content="类加载的时机" /><link rel="canonical" href="https://malinkang.cn/posts/understanding-the-jvm-class-loader/" /><meta property="og:url" content="https://malinkang.cn/posts/understanding-the-jvm-class-loader/" /><meta property="og:site_name" content="malinkang" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-08-27T21:39:36+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《深入理解JVM》第7章虚拟机类加载机制" /><meta name="twitter:site" content="@malinkang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"类加载的时机","headline":"《深入理解JVM》第7章虚拟机类加载机制","dateModified":"2021-07-07T14:54:59+08:00","url":"https://malinkang.cn/posts/understanding-the-jvm-class-loader/","datePublished":"2016-08-27T21:39:36+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://malinkang.cn/posts/understanding-the-jvm-class-loader/"},"@context":"https://schema.org"}</script><title>《深入理解JVM》第7章虚拟机类加载机制 | malinkang</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="malinkang"><meta name="application-name" content="malinkang"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://malinkang-1253444926.cos.ap-beijing.myqcloud.com/images/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">malinkang</a></div><div class="site-subtitle font-italic">人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/malinkang" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/malinkang" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['linkang.ma','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>《深入理解JVM》第7章虚拟机类加载机制</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《深入理解JVM》第7章虚拟机类加载机制</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> malinkang </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Aug 27, 2016, 9:39 PM +0800" prep="on" > Aug 27, 2016 <i class="unloaded">2016-08-27T21:39:36+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 7, 2021, 2:54 PM +0800" prefix="Updated " > Jul 7 <i class="unloaded">2021-07-07T14:54:59+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5385 words">29 min</span></div></div><div class="post-content"><h2 id="类加载的时机">类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。</p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><p>什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”。</p><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</ol><p>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</p><p>被动引用例子一：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"SuperClass init!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">123</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SubClass</span> <span class="kd">extends</span> <span class="nc">SuperClass</span><span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"SubClass init!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NotInitialization</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">SubClass</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>上述代码运行之后，只会输出“SuperClass init!”，而不会输出“SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过<code class="language-plaintext highlighter-rouge">-XX:+TraceClassLoading</code>参数观察到此操作会导致子类的加载。</p><p>被动引用例子二：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NotInitialization</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SuperClass</span><span class="o">[]</span> <span class="n">sca</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SuperClass</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>运行之后发现没有输出“SuperClass init!”，说明并没有触发类SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为“[LSuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p><p>这个类代表了一个元素类型为SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p><p>被动引用例子三：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstClass</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ConstClass init!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">HELLO_WORLD</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NotInitialization</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ConstClass</span><span class="o">.</span><span class="na">HELLO_WORLD</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>上述代码运行之后，也没有输出“ConstClass init!”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p><p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[插图]，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</clinit></p><h2 id="类的加载过程">类的加载过程</h2><p>“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</ol><p>相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2 id="验证">验证</h2><h2 id="准备">准备</h2><h2 id="解析">解析</h2><h2 id="类加载器">类加载器</h2><p>一个完整的 Java 程序是由多个 .class 文件组成的，在程序运行过程中，需要将这些 .class 文件加载到 JVM 中才可以使用。而负责加载这些 .class 文件的就是类加载器（ClassLoader）。</p><p>在 Java 程序启动的时候，并不会一次性加载程序中所有的 .class 文件，而是在程序的运行过程中，动态地加载相应的类到内存中。</p><p>通常情况下,Java 程序中的 .class 文件会在以下 2 种情况下被 ClassLoader 主动加载到内存中：</p><ul><li><p>调用类构造器</p><li><p>调用类中的静态（static）变量或者静态方法</p></ul><p>Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p><p>从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p><ul><li>启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如代码清单7-9所示为java.lang.ClassLoader.getClassLoader()方法的代码片段。</JAVA_HOME><li><p>扩展类加载器（Extension ClassLoader）：这个加载器由<code class="language-plaintext highlighter-rouge">sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p><li>应用程序类加载器（Application ClassLoader）：这个类加载器由<code class="language-plaintext highlighter-rouge">sun.misc.Launcher$App-ClassLoader</code>实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示。</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79019407ad4d4506b332f1d263ca0c1b~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p><h3 id="双亲委派模型">双亲委派模型</h3><p>图中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">//ClassLoader</span>
<span class="kd">protected</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">loadClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">ClassNotFoundException</span>
<span class="o">{</span>
        <span class="c1">// First, check if the class has already been loaded</span>
        <span class="c1">//判断是否已经被加载</span>
        <span class="c1">//①</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>  <span class="c1">//没有加载调用父加载器加载</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="c1">//②</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//③</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// ClassNotFoundException thrown if class not found</span>
                <span class="c1">// from the non-null parent class loader</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// If still not found, then invoke findClass in order</span>
                <span class="c1">// to find the class.</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span><span class="c1">//④</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ol><li><p>判断该 Class 是否已加载，如果已加载，则直接将该 Class 返回。</p><li><p>如果该 Class 没有被加载过，则判断 parent 是否为空，如果不为空则将加载的任务委托给parent。</p><li><p>如果 parent == null，则直接调用 BootstrapClassLoader 加载该类。</p><li><p>如果 parent 或者 BootstrapClassLoader 都没有加载成功，则调用当前 ClassLoader 的 findClass 方法继续尝试加载。</p></ol><h2 id="android中的classloader">Android中的ClassLoader</h2><p>本质上，Android 和传统的 JVM 是一样的，也需要通过 ClassLoader 将目标类加载到内存，类加载器之间也符合双亲委派模型。但是在 Android 中， ClassLoader 的加载细节有略微的差别。</p><p>在 Android 虚拟机里是无法直接运行 .class 文件的，Android 会将所有的 .class 文件转换成一个 .dex 文件，并且 Android 将加载 .dex 文件的实现封装在 BaseDexClassLoader 中，而我们一般只使用它的两个子类：PathClassLoader 和 DexClassLoader。</p><h3 id="pathclassloader">PathClassLoader</h3><p>PathClassLoader 用来加载系统 apk 和被安装到手机中的 apk 内的 dex 文件。它的 2 个构造函数如下：</p><p>参数说明：</p><ul><li><p>dexPath：dex 文件路径，或者包含 dex 文件的 jar 包路径；</p><li><p>librarySearchPath：C/C++ native 库的路径。</p></ul><p>PathClassLoader 里面除了这 2 个构造方法以外就没有其他的代码了，具体的实现都是在 BaseDexClassLoader 里面，其 dexPath 比较受限制，一般是已经安装应用的 apk 文件路径。</p><h3 id="dexclassloader">DexClassLoader</h3><p>对比 PathClassLoader 只能加载已经安装应用的 dex 或 apk 文件，DexClassLoader 则没有此限制，可以从 SD 卡上加载包含 class.dex 的 .jar 和 .apk 文件</p><h3 id="basedexclassloader">BaseDexClassLoader</h3><p>先来看一眼 BaseClassLoader 的结构：</p><p>其中有个重要的字段 private final DexPathList pathList ，其继承 ClassLoader 实现的 findClass() 、findResource() 均是基于 pathList 来实现的。</p><p><code class="language-plaintext highlighter-rouge">DexPathList</code>构造函数</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="nc">DexPathList</span><span class="o">(</span><span class="nc">ClassLoader</span> <span class="n">definingContext</span><span class="o">,</span> <span class="nc">String</span> <span class="n">dexPath</span><span class="o">,</span>
        <span class="nc">String</span> <span class="n">librarySearchPath</span><span class="o">,</span> <span class="nc">File</span> <span class="n">optimizedDirectory</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isTrusted</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">definingContext</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">(</span><span class="s">"definingContext == null"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">dexPath</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">(</span><span class="s">"dexPath == null"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">optimizedDirectory</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">optimizedDirectory</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span>  <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
                        <span class="s">"optimizedDirectory doesn't exist: "</span>
                        <span class="o">+</span> <span class="n">optimizedDirectory</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(!(</span><span class="n">optimizedDirectory</span><span class="o">.</span><span class="na">canRead</span><span class="o">()</span>
                            <span class="o">&amp;&amp;</span> <span class="n">optimizedDirectory</span><span class="o">.</span><span class="na">canWrite</span><span class="o">()))</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
                        <span class="s">"optimizedDirectory not readable/writable: "</span>
                        <span class="o">+</span> <span class="n">optimizedDirectory</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">this</span><span class="o">.</span><span class="na">definingContext</span> <span class="o">=</span> <span class="n">definingContext</span><span class="o">;</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">IOException</span><span class="o">&gt;</span> <span class="n">suppressedExceptions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">IOException</span><span class="o">&gt;();</span>
        <span class="c1">// save dexPath for BaseDexClassLoader</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dexElements</span> <span class="o">=</span> <span class="n">makeDexElements</span><span class="o">(</span><span class="n">splitDexPath</span><span class="o">(</span><span class="n">dexPath</span><span class="o">),</span> <span class="n">optimizedDirectory</span><span class="o">,</span>
                                           <span class="n">suppressedExceptions</span><span class="o">,</span> <span class="n">definingContext</span><span class="o">,</span> <span class="n">isTrusted</span><span class="o">);</span>

        <span class="c1">// Native libraries may exist in both the system and</span>
        <span class="c1">// application library paths, and we use this search order:</span>
        <span class="c1">//</span>
        <span class="c1">//   1. This class loader's library path for application libraries (librarySearchPath):</span>
        <span class="c1">//   1.1. Native library directories</span>
        <span class="c1">//   1.2. Path to libraries in apk-files</span>
        <span class="c1">//   2. The VM's library path from the system property for system libraries</span>
        <span class="c1">//      also known as java.library.path</span>
        <span class="c1">//</span>
        <span class="c1">// This order was reversed prior to Gingerbread; see http://b/2933456.</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nativeLibraryDirectories</span> <span class="o">=</span> <span class="n">splitPaths</span><span class="o">(</span><span class="n">librarySearchPath</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">systemNativeLibraryDirectories</span> <span class="o">=</span>
                <span class="n">splitPaths</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"java.library.path"</span><span class="o">),</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nativeLibraryPathElements</span> <span class="o">=</span> <span class="n">makePathElements</span><span class="o">(</span><span class="n">getAllNativeLibraryDirectories</span><span class="o">());</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">suppressedExceptions</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">dexElementsSuppressedExceptions</span> <span class="o">=</span>
                <span class="n">suppressedExceptions</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">IOException</span><span class="o">[</span><span class="n">suppressedExceptions</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">dexElementsSuppressedExceptions</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>接受之前传进来的包含 dex 的 apk/jar/dex 的路径集、native 库的路径集和缓存优化的 dex 文件的路径，然后调用 makePathElements() 方法生成一个 Element[] dexElements 数组，Element 是 DexPathList 的一个嵌套类： <code class="language-plaintext highlighter-rouge">makeDexElements</code>方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre> <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Element</span><span class="o">[]</span> <span class="nf">makeDexElements</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">File</span><span class="o">&gt;</span> <span class="n">files</span><span class="o">,</span> <span class="nc">File</span> <span class="n">optimizedDirectory</span><span class="o">,</span>
         <span class="nc">List</span><span class="o">&lt;</span><span class="nc">IOException</span><span class="o">&gt;</span> <span class="n">suppressedExceptions</span><span class="o">,</span> <span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isTrusted</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">Element</span><span class="o">[]</span> <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Element</span><span class="o">[</span><span class="n">files</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span> <span class="c1">//创建数组</span>
   <span class="kt">int</span> <span class="n">elementsPos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
   <span class="cm">/*
    * Open all files and load the (direct or contained) dex files up front.
    */</span>
   <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//遍历文件</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">())</span> <span class="o">{</span><span class="c1">//如果是文件夹直接创建Element给数组赋值</span>
           <span class="c1">// We support directories for looking up resources. Looking up resources in</span>
           <span class="c1">// directories is useful for running libcore tests.</span>
           <span class="n">elements</span><span class="o">[</span><span class="n">elementsPos</span><span class="o">++]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Element</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
       <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
           <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
           <span class="nc">DexFile</span> <span class="n">dex</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="no">DEX_SUFFIX</span><span class="o">))</span> <span class="o">{</span><span class="c1">//如果是dex文件</span>
               <span class="c1">// Raw dex file (not inside a zip/jar).</span>
               <span class="k">try</span> <span class="o">{</span><span class="c1">//加载dex文件</span>
                   <span class="n">dex</span> <span class="o">=</span> <span class="n">loadDexFile</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">optimizedDirectory</span><span class="o">,</span> <span class="n">loader</span><span class="o">,</span> <span class="n">elements</span><span class="o">);</span>
                   <span class="k">if</span> <span class="o">(</span><span class="n">dex</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                       <span class="n">elements</span><span class="o">[</span><span class="n">elementsPos</span><span class="o">++]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Element</span><span class="o">(</span><span class="n">dex</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                   <span class="o">}</span>
               <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">suppressed</span><span class="o">)</span> <span class="o">{</span>
                   <span class="nc">System</span><span class="o">.</span><span class="na">logE</span><span class="o">(</span><span class="s">"Unable to load dex file: "</span> <span class="o">+</span> <span class="n">file</span><span class="o">,</span> <span class="n">suppressed</span><span class="o">);</span>
                   <span class="n">suppressedExceptions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">suppressed</span><span class="o">);</span>
               <span class="o">}</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="k">try</span> <span class="o">{</span>
                   <span class="n">dex</span> <span class="o">=</span> <span class="n">loadDexFile</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">optimizedDirectory</span><span class="o">,</span> <span class="n">loader</span><span class="o">,</span> <span class="n">elements</span><span class="o">);</span>
               <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">suppressed</span><span class="o">)</span> <span class="o">{</span>
                   <span class="cm">/*
                    * IOException might get thrown "legitimately" by the DexFile constructor if
                    * the zip file turns out to be resource-only (that is, no classes.dex file
                    * in it).
                    * Let dex == null and hang on to the exception to add to the tea-leaves for
                    * when findClass returns null.
                    */</span>
                   <span class="n">suppressedExceptions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">suppressed</span><span class="o">);</span>
               <span class="o">}</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">dex</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                   <span class="n">elements</span><span class="o">[</span><span class="n">elementsPos</span><span class="o">++]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Element</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
               <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                   <span class="n">elements</span><span class="o">[</span><span class="n">elementsPos</span><span class="o">++]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Element</span><span class="o">(</span><span class="n">dex</span><span class="o">,</span> <span class="n">file</span><span class="o">);</span>
               <span class="o">}</span>
           <span class="o">}</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">dex</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">isTrusted</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">dex</span><span class="o">.</span><span class="na">setTrusted</span><span class="o">();</span>
           <span class="o">}</span>
       <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
           <span class="nc">System</span><span class="o">.</span><span class="na">logW</span><span class="o">(</span><span class="s">"ClassLoader referenced unknown path: "</span> <span class="o">+</span> <span class="n">file</span><span class="o">);</span>
       <span class="o">}</span>
   <span class="o">}</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">elementsPos</span> <span class="o">!=</span> <span class="n">elements</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">elements</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="n">elementsPos</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="n">elements</span><span class="o">;</span>
 <span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">BaseDexClassLoader</code>的<code class="language-plaintext highlighter-rouge">findClass</code>方法</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre> <span class="nd">@Override</span>
<span class="kd">protected</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">findClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
    <span class="c1">// First, check whether the class is present in our shared libraries.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sharedLibraryLoaders</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ClassLoader</span> <span class="n">loader</span> <span class="o">:</span> <span class="n">sharedLibraryLoaders</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">loader</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">ignored</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// Check whether the class in question is present in the dexPath that</span>
    <span class="c1">// this classloader operates on.</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Throwable</span><span class="o">&gt;</span> <span class="n">suppressedExceptions</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Throwable</span><span class="o">&gt;();</span>
    <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pathList</span><span class="o">.</span><span class="na">findClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">suppressedExceptions</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ClassNotFoundException</span> <span class="n">cnfe</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassNotFoundException</span><span class="o">(</span>
                <span class="s">"Didn't find class \""</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"\" on path: "</span> <span class="o">+</span> <span class="n">pathList</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span> <span class="o">:</span> <span class="n">suppressedExceptions</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cnfe</span><span class="o">.</span><span class="na">addSuppressed</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="n">cnfe</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>接下来看以下 DexPathList 的 findClass() 方法，其根据传入的完整的类名来加载对应的 class，源码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre> <span class="kd">public</span> <span class="nc">Class</span> <span class="nf">findClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Throwable</span><span class="o">&gt;</span> <span class="n">suppressed</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">// 遍历 dexElements 数组，依次寻找对应的 class，一旦找到就终止遍历</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Element</span> <span class="n">element</span> <span class="o">:</span> <span class="n">dexElements</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DexFile</span> <span class="n">dex</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">dexFile</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dex</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">dex</span><span class="o">.</span><span class="na">loadClassBinaryName</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">definingContext</span><span class="o">,</span> <span class="n">suppressed</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">clazz</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">clazz</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 抛出异常</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dexElementsSuppressedExceptions</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">suppressed</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">dexElementsSuppressedExceptions</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span> 
</pre></table></code></div></div><p>这里有关于热修复实现的一个点，就是将补丁 dex 文件放到 dexElements 数组前面，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的，虽然说起来较为简单，但是实现起来还有很多细节需要注意，本文先热身，后期再分析具体实现。</p><p>至此，BaseDexClassLader 寻找 class 的路线就清晰了：</p><ol><li>当传入一个完整的类名，调用 BaseDexClassLader 的 findClass(String name) 方法<li>BaseDexClassLader 的 findClass 方法会交给 DexPathList 的 findClass(String name, List<Throwable> suppressed 方法处理</Throwable><li>在 DexPathList 方法的内部，会遍历 dexFile ，通过 DexFile 的 dex.loadClassBinaryName(name, definingContext, suppressed) 来完成类的加载</ol><h2 id="参考">参考</h2><ul><li><a href="https://jaeger.itscoder.com/android/2016/08/27/android-classloader.html">热修复入门：Android 中的 ClassLoader</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/java/'>Java</a>, <a href='/categories/jvm/'>JVM</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/" class="post-tag no-text-decoration" >深入理解JVM</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《深入理解JVM》第7章虚拟机类加载机制 - malinkang&url=https://malinkang.cn/posts/understanding-the-jvm-class-loader/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《深入理解JVM》第7章虚拟机类加载机制 - malinkang&u=https://malinkang.cn/posts/understanding-the-jvm-class-loader/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=《深入理解JVM》第7章虚拟机类加载机制 - malinkang&url=https://malinkang.cn/posts/understanding-the-jvm-class-loader/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dagger-guide/">Dagger使用指南</a><li><a href="/posts/understanding-the-jvm-runtime-data-areas/">《深入理解JVM》第2章Java内存区域与内存溢出异常</a><li><a href="/posts/understanding-the-jvm-garbage-collection/">《深入理解JVM》第3章垃圾收集器</a><li><a href="/posts/understanding-the-jvm-class-file-structure/">《深入理解JVM》第6章类文件结构</a><li><a href="/posts/understanding-the-jvm-class-loader/">《深入理解JVM》第7章虚拟机类加载机制</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a> <a class="post-tag" href="/tags/thinking-in-java/">Thinking in Java</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/kotlin/">Kotlin</a> <a class="post-tag" href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a> <a class="post-tag" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/">深入理解JVM</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/databinding/">databinding</a> <a class="post-tag" href="/tags/recyclerview/">RecyclerView</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/understanding-the-jvm-runtime-data-areas/"><div class="card-body"> <span class="timeago small" > Aug 6, 2016 <i class="unloaded">2016-08-06T21:39:36+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《深入理解JVM》第2章Java内存区域与内存溢出异常</h3><div class="text-muted small"><p> 运行时数据区域 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示。 程序计数器 程序计数器（Program Co...</p></div></div></a></div><div class="card"> <a href="/posts/understanding-the-jvm-garbage-collection/"><div class="card-body"> <span class="timeago small" > Aug 13, 2016 <i class="unloaded">2016-08-13T21:39:36+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《深入理解JVM》第3章垃圾收集器</h3><div class="text-muted small"><p> 垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”了。 判断是对象是否应该被回收 引用计数算法 引用计数算法（Reference Counting）就是对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 优点：原理简单，判定效率也很高...</p></div></div></a></div><div class="card"> <a href="/posts/understanding-the-jvm-class-file-structure/"><div class="card-body"> <span class="timeago small" > Aug 20, 2016 <i class="unloaded">2016-08-20T21:39:36+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《深入理解JVM》第6章类文件结构</h3><div class="text-muted small"><p> Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/understanding-the-jvm-class-file-structure/" class="btn btn-outline-primary" prompt="Older"><p>《深入理解JVM》第6章类文件结构</p></a> <a href="/posts/understanding-the-jvm-execution-engine/" class="btn btn-outline-primary" prompt="Newer"><p>《深入理解JVM》第8章虚拟机字节码执行引擎</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//malinkang-cn.disqus.com/embed.js', disqusConfig: function() { this.page.title = '《深入理解JVM》第7章虚拟机类加载机制'; this.page.url = 'https://malinkang.cn/posts/understanding-the-jvm-class-loader/'; this.page.identifier = '/posts/understanding-the-jvm-class-loader/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/malinkang">malinkang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a> <a class="post-tag" href="/tags/thinking-in-java/">Thinking in Java</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/kotlin/">Kotlin</a> <a class="post-tag" href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a> <a class="post-tag" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/">深入理解JVM</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/databinding/">databinding</a> <a class="post-tag" href="/tags/recyclerview/">RecyclerView</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://malinkang.cn{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>

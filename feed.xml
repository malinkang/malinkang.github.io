<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://malinkang.cn/</id><title>malinkang</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-07-08T21:03:07+08:00</updated> <author> <name>malinkang</name> <uri>https://malinkang.cn/</uri> </author><link rel="self" type="application/atom+xml" href="https://malinkang.cn/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://malinkang.cn/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 malinkang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>系统闹钟源码分析</title><link href="https://malinkang.cn/posts/deskclock-analysis/" rel="alternate" type="text/html" title="系统闹钟源码分析" /><published>2021-01-19T17:21:04+08:00</published> <updated>2021-01-19T17:21:04+08:00</updated> <id>https://malinkang.cn/posts/deskclock-analysis/</id> <content src="https://malinkang.cn/posts/deskclock-analysis/" /> <author> <name>malinkang</name> </author> <summary> 核心类 UI部分 DeskClock：主界面，由ViewPager实现。 DeskClockFragment：首页四个Fragment的基类。 AlarmClockFragment：闹钟Fragment ClockFragment：时钟Fragment StopwatchFragment：秒表Fragment TimerFragment：定时器Fragment 数据 ClockDatabaseHelper：数据库Helper，闹钟应用创建了两表，表alarm_templates存储所有的闹钟，alarm_instances存储了开启的闹钟。 ClockProvider：ContentProvider Ala... </summary> </entry> <entry><title>绑定服务</title><link href="https://malinkang.cn/posts/bound-services/" rel="alternate" type="text/html" title="绑定服务" /><published>2020-12-15T03:18:41+08:00</published> <updated>2020-12-15T03:18:41+08:00</updated> <id>https://malinkang.cn/posts/bound-services/</id> <content src="https://malinkang.cn/posts/bound-services/" /> <author> <name>malinkang</name> </author> <summary> 绑定服务是 Service 类的实现，可让其他应用与其进行绑定和交互。如要为服务提供绑定，您必须实现 onBind() 回调方法。该方法会返回 IBinder 对象，该对象定义的编程接口可供客户端用来与服务进行交互。 客户端通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。bindService() 的返回值表明所请求的服务是否存在，以及是否允许客户端访问该服务。当创建客户端与服务之间的连接时，Android 系统会调用 ServiceConnection 上的 onServiceConnected()。onServiceConnected() 方法包含 IBinder 参数，客户端随后会使用该参数与绑定服务进行通信。 您可以同时将多个客户端连接到服务。但是，系统会缓存 IBinder 服务通... </summary> </entry> <entry><title>WorkManager源码分析</title><link href="https://malinkang.cn/posts/workmanager-source-analysis/" rel="alternate" type="text/html" title="WorkManager源码分析" /><published>2020-12-08T04:40:56+08:00</published> <updated>2020-12-08T04:40:56+08:00</updated> <id>https://malinkang.cn/posts/workmanager-source-analysis/</id> <content src="https://malinkang.cn/posts/workmanager-source-analysis/" /> <author> <name>malinkang</name> </author> <summary> WorkManager WorkManger是一个单例对象, 但是从例子代码中没有看的调用初始化的地方。通过文档可知 WorkManager有两种初始化方式: 应用启动之后, 它自己自动初始化 按需初始化, 到了需要用到的地方才初始化。可以避免初始化影响应用的启动速度。 自动初始化 WorkManagerInitializer继承ContentProvider。在应用启动之后会调用 onCreate(), 所以自动初始化就是在 onCreate() 中执行WorkManager 的初始化。 public class WorkManagerInitializer extends ContentProvider { @Override public boolean onCreate() { // Initialize WorkMana... </summary> </entry> <entry><title>ButterKnife源码分析</title><link href="https://malinkang.cn/posts/butterknife-source-analysis/" rel="alternate" type="text/html" title="ButterKnife源码分析" /><published>2020-12-03T00:37:06+08:00</published> <updated>2020-12-03T00:37:06+08:00</updated> <id>https://malinkang.cn/posts/butterknife-source-analysis/</id> <content src="https://malinkang.cn/posts/butterknife-source-analysis/" /> <author> <name>malinkang</name> </author> <summary> 本文分析的源码为8.4.0。 项目结构 butterknife包含ButterKnife核心的Api，如ButterKnife。butterknife-annotations包含了所有定义的注解。butterknife-compiler包含了生成模板代码的代码。这里我们重点研究ButterKnife是如何生成模板代码以及在我们的类中是如何调用的。 核心类 ViewBinding是一个接口，有两个直接的子类FieldViewBinding和MethodViewBinding。 FieldViewBinding封装了使用@BindView注解的Field的信息。 private final String name;//字段名 private final TypeName type;//类型 private final boolean required;//是否必须 Me... </summary> </entry> <entry><title>RxJava源码分析</title><link href="https://malinkang.cn/posts/rxjava-source-analysis/" rel="alternate" type="text/html" title="RxJava源码分析" /><published>2020-11-28T07:47:34+08:00</published> <updated>2021-05-28T10:48:44+08:00</updated> <id>https://malinkang.cn/posts/rxjava-source-analysis/</id> <content src="https://malinkang.cn/posts/rxjava-source-analysis/" /> <author> <name>malinkang</name> </author> <summary> RxJava创建过程 create() 调用create()创建Observable。 Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { @Override public void subscribe(@NonNull ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Throwable { emitter.onNext(2); } }).subscribe(new Consumer&amp;lt;Integer&amp;gt;() { @Override public void accept(Integer integer) throws Throwable { System.out.print... </summary> </entry> </feed>

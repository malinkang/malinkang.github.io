<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</title>
    <link>https://malinkang.cn/</link>
    <description>Recent content on 人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 09 Apr 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://malinkang.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Recyclerview源码分析三</title>
      <link>https://malinkang.cn/post/recyclerview-analysis-3/</link>
      <pubDate>Fri, 04 Sep 2020 16:39:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/recyclerview-analysis-3/</guid>
      <description>上一篇分析RecyclerView整体流程的时候提到，RecyclerView缓存机制比较复杂，所以这一篇单独分析一下RecyclerVie</description>
    </item>
    
    <item>
      <title>Recyclerview源码分析二</title>
      <link>https://malinkang.cn/post/recyclerview-analysis-2/</link>
      <pubDate>Thu, 03 Sep 2020 16:39:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/recyclerview-analysis-2/</guid>
      <description>&lt;p&gt;在上一篇文章中，我们主要分析了&lt;code&gt;RecyclerView&lt;/code&gt;中的几个重要的内部类。今天我们就把它们串起来，看它们分别是如何工作的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Recyclerview源码分析一</title>
      <link>https://malinkang.cn/post/recyclerview-analysis-1/</link>
      <pubDate>Wed, 02 Sep 2020 16:39:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/recyclerview-analysis-1/</guid>
      <description>&lt;p&gt;&lt;code&gt;RecyclerView&lt;/code&gt;是我们开发中最常用的控件，&lt;code&gt;RecyclerView&lt;/code&gt;是如何工作的，如何处理缓存的有助于解决一些使用&lt;code&gt;RecyclerView&lt;/code&gt;的bug和优化&lt;code&gt;RecyclerView&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>什么是响应式编程</title>
      <link>https://malinkang.cn/post/what-is-reactive-programming/</link>
      <pubDate>Tue, 28 Jul 2020 10:44:19 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/what-is-reactive-programming/</guid>
      <description>&lt;p&gt;最近被人问起什么是响应式编程，虽然使用&lt;code&gt;RxJava&lt;/code&gt;已经五六年了，但真正让我用一句话来概括什么是响应式编程还真有点困难。打开google，搜索什么是函数编程，看了几遍文章也没有明确的答案，这里谈谈自己的理解。&lt;/p&gt;
&lt;p&gt;响应式编程一个核心的概念是流（stream）。可以基于任何东西创建数据流。流非常轻便，并且无处不在，任何东西都可以是一个流：变量，用户输入，属性，缓存，数据结构等等。除此之外，我们有很多功能强大的函数，可以对这些流进行合并、过滤、转变等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Epoxy Models</title>
      <link>https://malinkang.cn/post/epoxy-models/</link>
      <pubDate>Sun, 05 Jan 2020 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/epoxy-models/</guid>
      <description>概览（Overview） Epoxy uses EpoxyModel objects to decide which views to display and how to bind data to them. This is similar to the popular ViewModel pattern. Models also allow you to control other aspects of the view, such as the grid span size, id, and saved state. Epoxy使用Epoxy</description>
    </item>
    
    <item>
      <title>Improve App Performance With Kotlin Coroutines</title>
      <link>https://malinkang.cn/post/improve-app-performance-with-kotlin-coroutines/</link>
      <pubDate>Tue, 15 Oct 2019 19:02:36 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/improve-app-performance-with-kotlin-coroutines/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.android.com/kotlin/coroutines&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协程是一种并发设计模式，您可以在&lt;code&gt;Android&lt;/code&gt;上使用它来简化异步执行的代码。 &lt;code&gt;Coroutines&lt;/code&gt;在版本1.3中添加到&lt;code&gt;Kotlin&lt;/code&gt;，并基于其他语言的既定概念。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Android&lt;/code&gt;上，协同程序有助于解决两个主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理长时间运行的任务，否则可能会阻止主线程并导致应用冻结。&lt;/li&gt;
&lt;li&gt;提供主安全性，或从主线程安全地调用网络或磁盘操作。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Dex文件格式分析</title>
      <link>https://malinkang.cn/post/dex-file-format/</link>
      <pubDate>Fri, 27 Sep 2019 10:04:55 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/dex-file-format/</guid>
      <description>&lt;p&gt;在刚学习Java的时候我们都会写一个&lt;code&gt;HelloWorld&lt;/code&gt;的示例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HelloWorld&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello,world!&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后通过&lt;code&gt;javac&lt;/code&gt;命令编译成字节码，然后调用&lt;code&gt;java&lt;/code&gt;命令机执行字节码。我们如何像&lt;code&gt;java&lt;/code&gt;一样在命令行里直接在命令行输出&lt;code&gt;Hello,world!&lt;/code&gt;呢。具体要执行如下操作：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Activity的启动流程</title>
      <link>https://malinkang.cn/post/android-activity-launch-process/</link>
      <pubDate>Tue, 24 Sep 2019 15:53:26 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-activity-launch-process/</guid>
      <description>&lt;p&gt;App启动的整体流程分为以下7个阶段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Launcher&lt;/code&gt;通知AMS，要启动&lt;code&gt;App&lt;/code&gt;，而且指定要启动&lt;code&gt;App&lt;/code&gt;的哪个页面（也就是首页）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AMS&lt;/code&gt;通知Launcher, “好了我知道了，没你什么事了”。同时，把要启动的首页记下来。&lt;/li&gt;
&lt;li&gt;Launcher当前页面进入Paused状态，然后通知AMS, “我睡了，你可以去找App了”。&lt;/li&gt;
&lt;li&gt;AMS检查App是否已经启动了。是，则唤起App即可。否，就要启动一个新的进程。AMS在新进程中创建一个ActivityThread对象，启动其中的main函数。&lt;/li&gt;
&lt;li&gt;App启动后，通知AMS, “我启动好了”。&lt;/li&gt;
&lt;li&gt;AMS翻出之前在2中存的值，告诉App，启动哪个页面。&lt;/li&gt;
&lt;li&gt;App启动首页，创建Context并与首页Activity关联。然后调用首页&lt;code&gt;Activity&lt;/code&gt;的onCreate函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此启动流程完成，可分成两部分：第1～3阶段，Launcher和AMS相互通信；第4～7阶段，App和AMS相互通信。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【译】避免Android中内存泄漏的9种方法</title>
      <link>https://malinkang.cn/post/9-ways-to-avoid-memory-leaks-in-android/</link>
      <pubDate>Mon, 10 Jun 2019 14:33:57 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/9-ways-to-avoid-memory-leaks-in-android/</guid>
      <description>原文，本文介绍了，引发内存泄露的常见情况，并给出了对应的修复方法。 I have been an android developer for quite some time now. And I realised（意识到） that most of that time, I tend to spend on adding</description>
    </item>
    
    <item>
      <title>Handler的使用和原理分析</title>
      <link>https://malinkang.cn/post/android-handler/</link>
      <pubDate>Fri, 26 Apr 2019 11:22:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-handler/</guid>
      <description>使用Handler 每个应用程序都有自己的特殊线程来运行UI对象，例如View对象;这个线程称为UI线程。在Android中，不允许非UI线程</description>
    </item>
    
    <item>
      <title>第2章 极限与连续性</title>
      <link>https://malinkang.cn/thomas-calculus/thomas-calculus-chapter2/</link>
      <pubDate>Tue, 16 Apr 2019 16:22:46 +0800</pubDate>
      
      <guid>https://malinkang.cn/thomas-calculus/thomas-calculus-chapter2/</guid>
      <description>2.2.2 极限法则 **定理1（极限法则）**若$L, M, c$和$k$是实数，并且 $$ \lim _{x \rightarrow c} f(x)=L, \lim _{x \rightarrow c} g(x)=M $$ 则有 （1）和法则 $$ \lim _{x \rightarrow c}(f(x)+g(x))=L+M $$ 两个函数之和的极限</description>
    </item>
    
    <item>
      <title>Column和Row详解</title>
      <link>https://malinkang.cn/post/flutter-widget-column/</link>
      <pubDate>Tue, 19 Mar 2019 14:21:37 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/flutter-widget-column/</guid>
      <description>MainAxisAlignment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69</description>
    </item>
    
    <item>
      <title>Android Build</title>
      <link>https://malinkang.cn/post/android-build/</link>
      <pubDate>Thu, 14 Mar 2019 15:18:46 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-build/</guid>
      <description>D8 Android Studio 3.0 推出了d8，并在3.1正式成为默认工具。它的作用是将“.class”文件编译为Dex文件，取代之前的dx工具。 R8 R8 在 Android Studio 3.1 中引入，志</description>
    </item>
    
    <item>
      <title>Android动态化</title>
      <link>https://malinkang.cn/post/android-dynamic/</link>
      <pubDate>Thu, 14 Mar 2019 15:18:46 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-dynamic/</guid>
      <description>移动互联网已经发展十年了，随着业务成熟和功能的相对稳定，整体重心开始偏向运营，强烈的运营需求对客户端架构和发布模式都提出了更高的要求。如果每</description>
    </item>
    
    <item>
      <title>Android网络优化</title>
      <link>https://malinkang.cn/post/android-network-performance/</link>
      <pubDate>Fri, 08 Mar 2019 09:54:39 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-network-performance/</guid>
      <description>在讲怎么去优化网络之前，我想先明确一下所谓的网络优化，究竟指的是什么？在我看来，核心内容有以下三个： 速度。在网络正常或者良好的时候，怎样更好</description>
    </item>
    
    <item>
      <title>Android优化之WebView优化</title>
      <link>https://malinkang.cn/post/android-webview-performance/</link>
      <pubDate>Thu, 07 Mar 2019 10:02:53 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-webview-performance/</guid>
      <description>百度APP-Android H5首屏优化实践</description>
    </item>
    
    <item>
      <title>Android电池优化</title>
      <link>https://malinkang.cn/post/android-battery-performance/</link>
      <pubDate>Thu, 07 Mar 2019 10:02:53 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-battery-performance/</guid>
      <description>耗电的背景知识 1.电池技术 手机电池的一些关键指标： 电池容量 充电时间 寿命 安全性 2.电量和硬件 3.电量和应用程序 Android耗电的演进历程 1.</description>
    </item>
    
    <item>
      <title>Android优化之安装包大小优化</title>
      <link>https://malinkang.cn/post/android-reduce-apk-size/</link>
      <pubDate>Tue, 05 Mar 2019 16:00:24 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-reduce-apk-size/</guid>
      <description>1.为什么要优化包体积 下载转化率 推广成本 应用市场 2.包体积与应用性能 包体积除了转化率的影响，它对我们应用性能还有哪些影响呢？ 安装时间。文件拷</description>
    </item>
    
    <item>
      <title>Android启动优化</title>
      <link>https://malinkang.cn/post/android-start-performance/</link>
      <pubDate>Tue, 05 Mar 2019 15:57:23 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-start-performance/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Android优化之内存优化</title>
      <link>https://malinkang.cn/post/android-memory-performance/</link>
      <pubDate>Tue, 05 Mar 2019 15:10:02 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-memory-performance/</guid>
      <description>目录 使用内存效率更高的代码结构 谨慎使用服务 使用经过优化的数据容器 谨慎对待代码抽象 针对序列化数据使用精简版-protobuf 避免内存抖动 移除会</description>
    </item>
    
    <item>
      <title>Android崩溃优化</title>
      <link>https://malinkang.cn/post/android-crash-performance/</link>
      <pubDate>Tue, 05 Mar 2019 10:08:28 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-crash-performance/</guid>
      <description>Android的两种崩溃 Android崩溃分为Java崩溃和Native崩溃。Java崩溃就是在Java代码中，出现了未捕获异常，导致程序异</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第8章 通用程序设计</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter8/</link>
      <pubDate>Thu, 28 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter8/</guid>
      <description>第45条：将局部变量的作用域最小化 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。 循环中提供了特殊的机会来将变量的作用</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第8章 通用程序设计</title>
      <link>https://malinkang.cn/post/effective-java-chapter8/</link>
      <pubDate>Thu, 28 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter8/</guid>
      <description>第45条：将局部变量的作用域最小化 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。 循环中提供了特殊的机会来将变量的作用</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第7章 方法</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter7/</link>
      <pubDate>Wed, 20 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter7/</guid>
      <description>第38条：检查参数的有效性 对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值会抛出的异常。一旦在文档中记录了对于方</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第7章 方法</title>
      <link>https://malinkang.cn/post/effective-java-chapter7/</link>
      <pubDate>Wed, 20 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter7/</guid>
      <description>第38条：检查参数的有效性 对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值会抛出的异常。一旦在文档中记录了对于方</description>
    </item>
    
    <item>
      <title>Container详解</title>
      <link>https://malinkang.cn/post/flutter-widget-container/</link>
      <pubDate>Tue, 19 Feb 2019 14:21:37 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/flutter-widget-container/</guid>
      <description>Container是一个拥有绘制、定位、调整大小的widget。 padding和margin padding和margin分别设置Contai</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第6章 枚举和注解</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter6/</link>
      <pubDate>Mon, 18 Feb 2019 09:58:30 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter6/</guid>
      <description>第30条：用enum代替int常量 在编程语言中还没有引入枚举类型之前，表示枚举类型的常量模式是声明一组具名的int常量，每个类型成员一个常量</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第6章 枚举和注解</title>
      <link>https://malinkang.cn/post/effective-java-chapter6/</link>
      <pubDate>Mon, 18 Feb 2019 09:58:30 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter6/</guid>
      <description>第30条：用enum代替int常量 在编程语言中还没有引入枚举类型之前，表示枚举类型的常量模式是声明一组具名的int常量，每个类型成员一个常量</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第5章 泛型</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter5/</link>
      <pubDate>Sat, 16 Feb 2019 16:20:11 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter5/</guid>
      <description>第23条：请不要在新代码中使用原生态类型 声明中具有一个或者多个类型参数（type parameter）的类或者接口就是泛型类或者接口。泛型类和</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第5章 泛型</title>
      <link>https://malinkang.cn/post/effective-java-chapter5/</link>
      <pubDate>Sat, 16 Feb 2019 16:20:11 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter5/</guid>
      <description>第23条：请不要在新代码中使用原生态类型 声明中具有一个或者多个类型参数（type parameter）的类或者接口就是泛型类或者接口。泛型类和</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第4章 类和接口</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter4/</link>
      <pubDate>Fri, 15 Feb 2019 16:25:04 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter4/</guid>
      <description>第13条：使类和成员的可访问性最小化 Java程序设计语言提供了许多机制来协助信息隐藏。访问控制（access control)机制决定了类、接</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第4章 类和接口</title>
      <link>https://malinkang.cn/post/effective-java-chapter4/</link>
      <pubDate>Fri, 15 Feb 2019 16:25:04 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter4/</guid>
      <description>第13条：使类和成员的可访问性最小化 Java程序设计语言提供了许多机制来协助信息隐藏。访问控制（access control)机制决定了类、接</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第3章 对于所有对象都通用的方法</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter3/</link>
      <pubDate>Tue, 12 Feb 2019 09:54:13 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter3/</guid>
      <description>第8条：覆盖equals时请遵守通用约定 在覆盖equals方法的时候，你必须要遵守它的通用约定。 自反性（reflexive）。对于任何非nu</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第3章 对于所有对象都通用的方法</title>
      <link>https://malinkang.cn/post/effective-java-chapter3/</link>
      <pubDate>Tue, 12 Feb 2019 09:54:13 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter3/</guid>
      <description>第8条：覆盖equals时请遵守通用约定 在覆盖equals方法的时候，你必须要遵守它的通用约定。 自反性（reflexive）。对于任何非nu</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第2章 创建和销毁对象</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter2/</link>
      <pubDate>Sat, 05 Jan 2019 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter2/</guid>
      <description>《Effective Java》经常出现在各个Java推荐书单里，自己也曾买过一本看了几章，便被束之高阁。最近发现第三版也已经出版了。所以把读</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第2章 创建和销毁对象</title>
      <link>https://malinkang.cn/post/effective-java-chapter2/</link>
      <pubDate>Sat, 05 Jan 2019 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter2/</guid>
      <description>《Effective Java》经常出现在各个Java推荐书单里，自己也曾买过一本看了几章，便被束之高阁。最近发现第三版也已经出版了。所以把读</description>
    </item>
    
    <item>
      <title>关于自我提升的思考</title>
      <link>https://malinkang.cn/post/up/</link>
      <pubDate>Sat, 05 Jan 2019 09:54:09 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/up/</guid>
      <description>从12年算起，自己也在软件开发这个行业已经近7年。自己也一直在从事Android移动开发。回顾自己的这7年，对自己是非常失望的。自己一直从事</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第8章 Lambda作为形参和返回值</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter8/</link>
      <pubDate>Wed, 12 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter8/</guid>
      <description>8.1 声明高阶函数 高阶函数就是以另一个函数作为参数或者返回值的函数。 8.1.1 函数类型 1 2 3 4 5 6 7 8 val sum = { x: Int, y: Int -&amp;gt; x + y } val action = { println(42)} run { println(sum(1,2)) //3 } run{ action()</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第7章 运算符重载及其他约定</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter7/</link>
      <pubDate>Sun, 09 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter7/</guid>
      <description>7.1 重载算术运算符 7.1.1 重载二元算术运算 1 2 3 4 5 6 7 8 data class Point(val x: Int, val y: Int) { operator fun plus(other: Point): Point { return Point(x + other.x, y + other.y) } } val p1 = Point(10, 20) val p2 = Point(30, 40) println(p1 + p2) //Point(x=40, y=60) {% code-tabs %} {% code-tabs-item t</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第6章 Kotlin的类型系统</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter6/</link>
      <pubDate>Thu, 06 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter6/</guid>
      <description>6.1 可空性 6.1.1 可空类型 1 2 //增加了null检查后，这段代码就可以编译了 fun strLenSafe(s: String?) = if (s != null) s.length else 0 6.1.2 类型的含义 6.1.3 安全调用运算符 安全调用运算符?允许把</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第5章 Lambda编程</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter5/</link>
      <pubDate>Tue, 04 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter5/</guid>
      <description>5.1 Lambda表达式和成员引用 5.1.1 Lambda简介：作为函数参数的代码块 1 2 3 4 5 6 button.setOnClickLisener(new OnClickListener(){ @Override public void onClick(View view){ //点击后执行的动作 } } 1 button.se</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第4章 类对象和接口</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter4/</link>
      <pubDate>Tue, 28 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter4/</guid>
      <description>4.1 定义类继承结构 4.1.1 Kotlin中的接口 1 2 3 4 5 6 7 8 //接口定义 interface Clickable { fun click() } //实现接口 class Button:Clickable{ override fun click() = println(&amp;#34;I was clicked&amp;#34;) } 接口的方法可以有一个默认实现。</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第3章 函数的定义与调用</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter3/</link>
      <pubDate>Sat, 25 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter3/</guid>
      <description>3.1 在kotlin中创建集合 1 2 3 4 5 6 7 val set = hashSetOf(1, 7, 53) val list = arrayListOf(1, 7, 53) val map = hashMapOf(1 to &amp;#34;one&amp;#34;, 7 to &amp;#34;seven&amp;#34;, 53 to &amp;#34;fifty-three&amp;#34;) //kotlin的javaClass等价于Java的</description>
    </item>
    
    <item>
      <title>Paging 库概述</title>
      <link>https://malinkang.cn/post/paging-library-overview/</link>
      <pubDate>Fri, 27 Jul 2018 14:44:49 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/paging-library-overview/</guid>
      <description>&lt;p&gt;分页库可帮助您一次加载和显示小块数据。按需加载部分数据可减少网络带宽和系统资源的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin作用域函数</title>
      <link>https://malinkang.cn/post/kotlin-scope-functions/</link>
      <pubDate>Fri, 27 Jul 2018 15:05:51 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-scope-functions/</guid>
      <description>&lt;p&gt;&lt;code&gt;Kotlin&lt;/code&gt;标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。当对一个对象调用这样的函数并提供一个&lt;code&gt;lambda&lt;/code&gt;表达式时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。共有以下五种：&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;、&lt;code&gt;with&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt; 以及&lt;code&gt;also&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些函数基本上做了同样的事情：在一个对象上执行一个代码块。不同的是这个对象在块中如何使用，以及整个表达式的结果是什么。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kotlin函数</title>
      <link>https://malinkang.cn/post/kotlin-functions/</link>
      <pubDate>Fri, 27 Jul 2018 15:05:51 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-functions/</guid>
      <description>函数声明 Kotlin中的函数使用fun关键字声明： 1 2 3 fun double(x: Int): Int { return 2 * x } 函数调用 调用函数使用传统的方法： 1 val result = double(2) 调用成员函数使用点表示</description>
    </item>
    
    <item>
      <title>Dagger2在Android中的使用</title>
      <link>https://malinkang.cn/post/dagger-android/</link>
      <pubDate>Wed, 25 Jul 2018 11:56:12 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/dagger-android/</guid>
      <description>&lt;p&gt;与其他大多数依赖注入框架相比，&lt;code&gt;Dagger2&lt;/code&gt;的主要优点之一是其严格生成的实现（无反射）意味着它可以在&lt;code&gt;Android&lt;/code&gt;应用程序中使用。但是，在&lt;code&gt;Android&lt;/code&gt;应用程序中使用&lt;code&gt;Dagger&lt;/code&gt;时仍有一些注意事项。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>实现navigation</title>
      <link>https://malinkang.cn/post/navigation-implementing/</link>
      <pubDate>Thu, 07 Jun 2018 16:13:46 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/navigation-implementing/</guid>
      <description>&lt;p&gt;导航体系结构组件简化了应用程序中目标之间导航的实现。目的地是应用中的特定屏幕。默认情况下，导航体系结构组件包括支持&lt;code&gt;fragment&lt;/code&gt;和&lt;code&gt;activity&lt;/code&gt;作为目标，但您也可以添加对新类型目标的支持。一组目的地组成一个应用程序的“导航图”。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LiveData概述</title>
      <link>https://malinkang.cn/post/livedata-overview/</link>
      <pubDate>Fri, 18 May 2018 16:47:47 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/livedata-overview/</guid>
      <description>&lt;p&gt;&lt;code&gt;LiveData&lt;/code&gt;是一个可观察的数据持有者类。与常规可观察性不同，&lt;code&gt;LiveData&lt;/code&gt;具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如&lt;code&gt;activity&lt;/code&gt;，&lt;code&gt;fragment&lt;/code&gt;或&lt;code&gt;service&lt;/code&gt;）的生命周期。 这确保&lt;code&gt;LiveData&lt;/code&gt;只更新处于活动生命周期状态的应用程序组件观察者。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>小花，再见</title>
      <link>https://malinkang.cn/post/goodbye-xiao-hua/</link>
      <pubDate>Sat, 08 Jul 2017 09:00:42 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/goodbye-xiao-hua/</guid>
      <description>&lt;p&gt;领养小花的最初目的就是为了给蛋黄找个伴。6月26日下午，我和珊珊顶着大太阳骑着自行车来到小沙河村接小花。小花比预想的要小的多，看着不像是他主人说的一个多月，顶多也就二十多天，而且眼中充满了泪水，当时没有多想，就领回来了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>生成绑定类</title>
      <link>https://malinkang.cn/post/generated-binding-classes/</link>
      <pubDate>Mon, 19 Jun 2017 20:01:58 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/generated-binding-classes/</guid>
      <description>&lt;p&gt;数据绑定库生成用于访问布局的变量和视图的绑定类。生成的绑定类将布局变量与布局中的视图链接起来。绑定类的名称和包可以自定义。所有生成的绑定类都继承自&lt;code&gt;ViewDataBinding&lt;/code&gt;类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>绑定适配器使用</title>
      <link>https://malinkang.cn/post/binding-adapters/</link>
      <pubDate>Tue, 13 Jun 2017 18:14:02 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/binding-adapters/</guid>
      <description>&lt;p&gt;绑定适配器负责对设置值进行适当的框架调用。一个例子是设置一个属性值，如调用&lt;code&gt;setText()&lt;/code&gt;方法。另一个例子是设置一个事件监听器，如调用&lt;code&gt;setOnClickListener()&lt;/code&gt;方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DataBinding绑定表达式使用</title>
      <link>https://malinkang.cn/post/binding-expressions/</link>
      <pubDate>Sun, 11 Jun 2017 18:14:02 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/binding-expressions/</guid>
      <description>&lt;p&gt;表达式语言允许您编写处理&lt;code&gt;View&lt;/code&gt;分发的事件的表达式。数据绑定库自动生成将布局中的&lt;code&gt;View&lt;/code&gt;与数据对象绑定所需的类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android自定义属性</title>
      <link>https://malinkang.cn/post/android-custom-attribute/</link>
      <pubDate>Tue, 21 Mar 2017 17:37:26 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-custom-attribute/</guid>
      <description>&lt;p&gt;创建自定义属性需要以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个自定义View。&lt;/li&gt;
&lt;li&gt;创建values/attrs.xml文件，并定义属性。&lt;/li&gt;
&lt;li&gt;在View中获取属性值并使用。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Dagger使用指南</title>
      <link>https://malinkang.cn/post/dagger-guide/</link>
      <pubDate>Mon, 25 Jul 2016 09:47:31 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/dagger-guide/</guid>
      <description>&lt;p&gt;任何应用程序中最好的类是那些做事情的类：&lt;code&gt;BarcodeDecoder&lt;/code&gt;，&lt;code&gt;KoopaPhysicsEngine&lt;/code&gt;和&lt;code&gt;AudioStreamer&lt;/code&gt;。 这些类具有依赖性; 也许是一个&lt;code&gt;BarcodeCameraFinder&lt;/code&gt;，&lt;code&gt;DefaultPhysicsEngine&lt;/code&gt;和一个&lt;code&gt;HttpStreamer&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Bitmap使用</title>
      <link>https://malinkang.cn/post/android-bitmap/</link>
      <pubDate>Fri, 24 Jun 2016 13:52:35 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-bitmap/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;bitmap占用内存计算&#34;&gt;Bitmap占用内存计算&lt;/h3&gt;
&lt;p&gt;Android的Bitmap对象提供了方法&lt;code&gt;getByteCount&lt;/code&gt;来获取Bitmap的字节数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getByteCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// int result permits bitmaps up to 46,340 x 46,340
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getRowBytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getHeight&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;getRowBytes()&lt;/code&gt;方法用来获取每行的字节数，内部调用一个native方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>创建 Android Studio Template</title>
      <link>https://malinkang.cn/post/android-studio-template/</link>
      <pubDate>Wed, 15 Jun 2016 10:40:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-studio-template/</guid>
      <description>&lt;p&gt;AndroidStudio 为我们提供了很多创建Activity以及其他类和文件夹的Template。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://malinkang.cn/images/android-studio-template-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Class文件结构</title>
      <link>https://malinkang.cn/post/class-file-format/</link>
      <pubDate>Tue, 05 Jan 2016 10:08:28 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/class-file-format/</guid>
      <description>&lt;p&gt;&lt;code&gt;Class&lt;/code&gt;文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在&lt;code&gt;Class&lt;/code&gt;文件之中，中间没有添加任何分隔符，这使得整个&lt;code&gt;Class&lt;/code&gt;文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。这种顺序称为“Big-Endian”。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>android反编译</title>
      <link>https://malinkang.cn/post/android-decompile/</link>
      <pubDate>Mon, 07 Dec 2015 15:48:40 +0800</pubDate>
      
      <guid>https://malinkang.cn/post/android-decompile/</guid>
      <description>&lt;h3 id=&#34;apktool&#34;&gt;Apktool&lt;/h3&gt;
&lt;p&gt;Apktool 能够从APK中解析出资源文件，xml文件以及生成smail文件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Studio常用插件</title>
      <link>https://malinkang.cn/post/android-studio-plugins/</link>
      <pubDate>Sun, 15 Jun 2014 10:40:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/android-studio-plugins/</guid>
      <description>ButterKnifeZelezny android-parcelable-intellij-plugin GsonFormat android-selector-chapek adb-idea android-material-design-icon-generator-plugin 扩展阅读 Android-Studio-Plugins Android Studio有哪些非常好用的插件？</description>
    </item>
    
    <item>
      <title>读书笔记</title>
      <link>https://malinkang.cn/reading-notes/</link>
      <pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://malinkang.cn/reading-notes/</guid>
      <description>数学 《托马斯微积分》 C++ 《C++ Primer 中文版（第 5 版）》 Java 《深入理解Java虚拟机（第2版）》 《Effective Java》 《Java编程思想 （第</description>
    </item>
    
    <item>
      <title>sqlite常用语法总结</title>
      <link>https://malinkang.cn/post/sqlite/</link>
      <pubDate>Wed, 26 Mar 2014 17:23:24 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/sqlite/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://malinkang.cn/readingnotes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://malinkang.cn/readingnotes/</guid>
      <description>读书笔记  Java  Effective Java    </description>
    </item>
    
  </channel>
</rss>
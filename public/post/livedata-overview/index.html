<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>LiveData概述 - 人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="malinkang" /><meta name="description" content="LiveData是一个可观察的数据持有者类。与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如activity，fragment或service）的生命周期。 这确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。
" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.71.0 with theme even" />


<link rel="canonical" href="https://malinkang.cn/post/livedata-overview/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.ab6ed46f161bdba676da3f071e37b038123f44e7125e330d80fc66955b18aaa5.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="LiveData概述" />
<meta property="og:description" content="LiveData是一个可观察的数据持有者类。与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如activity，fragment或service）的生命周期。 这确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://malinkang.cn/post/livedata-overview/" />
<meta property="article:published_time" content="2018-05-18T16:47:47+00:00" />
<meta property="article:modified_time" content="2018-05-18T16:47:47+00:00" />
<meta itemprop="name" content="LiveData概述">
<meta itemprop="description" content="LiveData是一个可观察的数据持有者类。与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如activity，fragment或service）的生命周期。 这确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。">
<meta itemprop="datePublished" content="2018-05-18T16:47:47&#43;00:00" />
<meta itemprop="dateModified" content="2018-05-18T16:47:47&#43;00:00" />
<meta itemprop="wordCount" content="5203">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LiveData概述"/>
<meta name="twitter:description" content="LiveData是一个可观察的数据持有者类。与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如activity，fragment或service）的生命周期。 这确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Malinkang&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Malinkang&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">LiveData概述</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-05-18 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#使用livedata的优点">使用LiveData的优点</a></li>
        <li><a href="#使用livedata对象">使用LiveData对象</a></li>
        <li><a href="#扩展livedata">扩展LiveData</a></li>
        <li><a href="#转换livedata">转换LiveData</a></li>
        <li><a href="#合并多个livedata源">合并多个LiveData源</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><code>LiveData</code>是一个可观察的数据持有者类。与常规可观察性不同，<code>LiveData</code>具有生命周期感知能力，这意味着它遵守其他应用程序组件（例如<code>activity</code>，<code>fragment</code>或<code>service</code>）的生命周期。 这确保<code>LiveData</code>只更新处于活动生命周期状态的应用程序组件观察者。</p>
<p><code>LiveData</code>作为一个用<code>Observer</code>类表示观察者，如果它的生命周期处于<code>STARTED</code>或<code>RESUMED</code>状态，则处于活动状态。<code>LiveData</code>仅通知活动状态的观察者更新。 非活动观察者注册观察<code>LiveData</code>对象不会收到有关更改的通知。</p>
<p>您可以注册与实现<code>LifecycleOwner</code>接口的对象配对的观察者。此关系允许在相应生命周期对象的状态更改为DESTROYED时删除观察者。这对于<code>activity</code>和<code>fragment</code>尤其有用，因为它们可以安全地观察<code>LiveData</code>对象，而不必担心泄漏 - 在其生命周期被销毁时，<code>activity</code>和<code>fragment</code>会立即取消订阅。</p>
<h3 id="使用livedata的优点">使用LiveData的优点</h3>
<p>使用LiveData提供以下优点：</p>
<h4 id="确保您的用户界面匹配您的数据状态">确保您的用户界面匹配您的数据状态</h4>
<p><code>LiveData</code>遵循观察者模式。当生命周期状态改变时，<code>LiveData</code>会通知观察者的对象。你可以合并你的代码以更新这些观察者对象中的UI。不是每一次数据改变时都更新UI，而是每次发生变化时，您的观察者可以更新UI。</p>
<h4 id="没有内存泄漏">没有内存泄漏</h4>
<p>观察者绑定到生命周期对象，并在其相关生命周期被摧毁后自行清理。</p>
<h4 id="由于停止活动而没有崩溃">由于停止活动而没有崩溃</h4>
<p>如果观察者的生命周期处于非活动状态，例如在后退堆栈中的活动，则它不会收到任何LiveData事件。</p>
<h4 id="没有更多的手动生命周期处理">没有更多的手动生命周期处理</h4>
<p>UI组件只是观察相关数据，不要停止或恢复观察。 <code>LiveData</code>自动管理所有这些，因为它在观察时感知到相关的生命周期状态更改。</p>
<h4 id="始终保持最新的数据">始终保持最新的数据</h4>
<p>如果生命周期变为非活动状态，它将在再次变为活动状态时收到最新数据。例如，后台活动在返回到前台后立即收到最新数据。</p>
<h4 id="合适的配置更改">合适的配置更改</h4>
<p>如果由于配置更改（如设备旋转）而重新创建<code>activity</code>或<code>fragment</code>，它会立即收到最新的可用数据。</p>
<h4 id="共享资源">共享资源</h4>
<p>您可以使用单例模式扩展<code>LiveData</code>对象以包装系统服务，以便它们可以在应用程序中共享。<code>LiveData</code>对象连接到系统服务一次，然后任何需要该资源的观察者都可以观看<code>LiveData</code>对象。</p>
<h3 id="使用livedata对象">使用LiveData对象</h3>
<p>按照以下步骤使用<code>LiveData</code>对象。</p>
<p>1.创建一个<code>LiveData</code>实例来保存某种类型的数据。这通常在您的<code>ViewModel</code>类中完成。</p>
<p>2.创建一个<code>Observer</code>对象，该对象定义<code>onChanged()</code>方法，该方法控制<code>LiveData</code>对象保存的数据更改时发生的情况。您通常在UI控制器中创建<code>Observer</code>对象，如<code>activity</code>或<code>fragment</code>。</p>
<p>3.使用<code>observe()</code>方法将<code>Observer</code>对象附加到<code>LiveData</code>对象。<code>observe()</code>方法使用<code>LifecycleOwner</code>对象。这将<code>Observer</code>对象订阅到<code>LiveData</code>对象，以便通知其更改。您通常将<code>Observer</code>对象附加到UI控制器中，如<code>activity</code>或<code>fragment</code>。</p>
<p>当您更新存储在<code>LiveData</code>对象中的值时，只要附加的<code>LifecycleOwner</code>处于活动状态，它就会触发所有已注册的观察者。</p>
<p><code>LiveData</code>允许UI控制器观察者订阅更新。当<code>LiveData</code>对象持有的数据更改时，UI会自动更新以作为响应。</p>
<h4 id="创建livedata对象">创建LiveData对象</h4>
<p><code>LiveData</code>是一个可用于任何数据的包装器，包括实现集合的对象（如List）。<code>LiveData</code>对象通常存储在<code>ViewModel</code>对象中，并通过<code>getter</code>方法访问，如以下示例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NameViewModel</span> <span class="kd">extends</span> <span class="n">ViewModel</span> <span class="o">{</span>

<span class="c1">// Create a LiveData with a String
</span><span class="c1"></span>	<span class="kd">private</span> <span class="n">MutableLiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">mCurrentName</span><span class="o">;</span>

	<span class="kd">public</span> <span class="n">MutableLiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getCurrentName</span><span class="o">()</span> <span class="o">{</span>
	    <span class="k">if</span> <span class="o">(</span><span class="n">mCurrentName</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
	        <span class="n">mCurrentName</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MutableLiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
	    <span class="o">}</span>
	    <span class="k">return</span> <span class="n">mCurrentName</span><span class="o">;</span>
	<span class="o">}</span>

<span class="c1">// Rest of the ViewModel...
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最初，LiveData对象中的数据未设置。</p>
<h4 id="观察livedata对象">观察LiveData对象</h4>
<p>在大多数情况下，出于以下原因，应用程序组件的<code>onCreate()</code>方法是开始观察<code>LiveData</code>对象的正确位置：</p>
<p>确保系统不会从<code>activity</code>或<code>fragment</code>的<code>onResume()</code>方法进行多余的调用。</p>
<p>确保<code>activity</code>或<code>fragment</code>具有一旦它变为活动状态即可显示的数据。只要应用程序组件处于<code>STARTED</code>状态，它就会从它所观察的<code>LiveData</code>对象中接收最新的值。这仅在要设置要观察的<code>LiveData</code>对象时才会发生。</p>
<p>通常，<code>LiveData</code>仅在数据更改时传递更新，并且仅传递给活动观察者。此行为的一个例外是，观察者在从非活动状态变为活动状态时也会收到更新。此外，如果观察者第二次从非激活状态变为激活状态，则只有在自上一次变为活动状态以来该值发生变化时才会收到更新。</p>
<p>以下示例代码说明了如何开始观察<code>LiveData</code>对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NameActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">NameViewModel</span> <span class="n">mModel</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="c1">// Other code to setup the activity...
</span><span class="c1"></span>
        <span class="c1">// Get the ViewModel.
</span><span class="c1"></span>        <span class="n">mModel</span> <span class="o">=</span> <span class="n">ViewModelProviders</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">this</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">NameViewModel</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>


        <span class="c1">// Create the observer which updates the UI.
</span><span class="c1"></span>        <span class="kd">final</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">nameObserver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onChanged</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">newName</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Update the UI, in this case, a TextView.
</span><span class="c1"></span>                <span class="n">mNameTextView</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">newName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="c1">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.
</span><span class="c1"></span>        <span class="n">mModel</span><span class="o">.</span><span class="na">getCurrentName</span><span class="o">().</span><span class="na">observe</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nameObserver</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用<code>nameObserver</code>作为参数传递<code>observe()</code>后，立即调用<code>onChanged()</code>，以提供存储在<code>mCurrentName</code>中的最新值。如果<code>LiveData</code>对象未在<code>mCurrentName</code>中设置值，则不调用<code>onChanged()</code>。</p>
<h4 id="更新livedata对象">更新LiveData对象</h4>
<p><code>LiveData</code>没有公开可用的方法来更新存储的数据。 MutableLiveData类公开<code>setValue(T)</code>和<code>postValue(T)</code>方法，如果需要编辑存储在<code>LiveData</code>对象中的值，则必须使用这些方法。通常在<code>ViewModel</code>中使用<code>MutableLiveData</code>，然后<code>ViewModel</code>只向观察者公开不可变的<code>LiveData</code>对象。</p>
<p>在建立观察者关系后，可以更新<code>LiveData</code>对象的值，如以下示例所示，当用户点击按钮时触发所有观察者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">mButton</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">anotherName</span> <span class="o">=</span> <span class="s">&#34;John Doe&#34;</span><span class="o">;</span>
        <span class="n">mModel</span><span class="o">.</span><span class="na">getCurrentName</span><span class="o">().</span><span class="na">setValue</span><span class="o">(</span><span class="n">anotherName</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></td></tr></table>
</div>
</div><p>在示例中调用<code>setValue(T)</code>会导致观察者用值<code>John Doe</code>调用它们的<code>onChanged()</code>方法。该示例显示按钮按下，但<code>setValue()</code>或<code>postValue()</code>可能因多种原因被调用来更新<code>mName</code>，包括响应网络请求或数据库加载完成;在所有情况下，调用<code>setValue()</code>或<code>postValue()</code>都会触发观察者并更新UI。</p>
<h4 id="和room一起使用livedata">和Room一起使用LiveData</h4>
<p><code>Room</code>持久性库支持返回<code>LiveData</code>对象的可观察查询。可观察查询是作为数据库访问对象（DAO）的一部分写入的。</p>
<p>当更新数据库时，会生成所有必要的代码以更新<code>LiveData</code>对象。生成的代码在需要时在后台线程上异步运行查询。这种模式对于保持UI中显示的数据与存储在数据库中的数据保持同步很有用。您可以在<code>Room</code>持久库指南中阅读关于<code>Room</code>和<code>DAO</code>的更多信息。</p>
<h3 id="扩展livedata">扩展LiveData</h3>
<p>如果观察者的生命周期处于<code>STARTED</code>或<code>RESUMED</code>状态，则<code>LiveData</code>将认为观察者处于活动状态。以下示例代码说明了如何扩展<code>LiveData</code>类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StockLiveData</span> <span class="kd">extends</span> <span class="n">LiveData</span><span class="o">&lt;</span><span class="n">BigDecimal</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">StockManager</span> <span class="n">mStockManager</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">SimplePriceListener</span> <span class="n">mListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimplePriceListener</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPriceChanged</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">setValue</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="kd">public</span> <span class="nf">StockLiveData</span><span class="o">(</span><span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mStockManager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StockManager</span><span class="o">(</span><span class="n">symbol</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onActive</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mStockManager</span><span class="o">.</span><span class="na">requestPriceUpdates</span><span class="o">(</span><span class="n">mListener</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onInactive</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mStockManager</span><span class="o">.</span><span class="na">removeUpdates</span><span class="o">(</span><span class="n">mListener</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>本示例中的价格监听器的实现包括以下重要方法：</p>
<p>当<code>LiveData</code>对象具有活动观察者时，将调用<code>onActive()</code>方法。这意味着您需要开始观察此方法的股价更新。</p>
<p>当<code>LiveData</code>对象没有任何活动观察者时，将调用<code>onInactive()</code>方法。由于没有观察员在监听，因此没有理由保持连接到<code>StockManager</code>服务。</p>
<p><code>setValue(T)</code>方法更新<code>LiveData</code>实例的值并通知任何活动观察者有关更改。</p>
<p>您可以使用<code>StockLiveData</code>类如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onActivityCreated</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onActivityCreated</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">LiveData</span><span class="o">&lt;</span><span class="n">BigDecimal</span><span class="o">&gt;</span> <span class="n">myPriceListener</span> <span class="o">=</span> <span class="o">...;</span>
        <span class="n">myPriceListener</span><span class="o">.</span><span class="na">observe</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">price</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// Update the UI.
</span><span class="c1"></span>        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>observe()</code>方法将作为LifecycleOwner<code>实例的</code>fragment`作为第一个参数传递。这样做表示此观察者被绑定到与所有者关联的生命周期对象，这意味着：</p>
<p>如果生命周期对象不处于活动状态，则即使值发生更改，也不会调用观察者。</p>
<p>生命周期对象被销毁后，观察者被自动删除。</p>
<p>LiveData对象支持生命周期意味着您可以在多个<code>activity</code>，<code>fragment</code>和<code>service</code>之间共享它们。为了保持示例简单，您可以按如下方式将<code>LiveData</code>类实现为单例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StockLiveData</span> <span class="kd">extends</span> <span class="n">LiveData</span><span class="o">&lt;</span><span class="n">BigDecimal</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">StockLiveData</span> <span class="n">sInstance</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">StockManager</span> <span class="n">mStockManager</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">SimplePriceListener</span> <span class="n">mListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimplePriceListener</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onPriceChanged</span><span class="o">(</span><span class="n">BigDecimal</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">setValue</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="nd">@MainThread</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">StockLiveData</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sInstance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StockLiveData</span><span class="o">(</span><span class="n">symbol</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sInstance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">StockLiveData</span><span class="o">(</span><span class="n">String</span> <span class="n">symbol</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mStockManager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StockManager</span><span class="o">(</span><span class="n">symbol</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onActive</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mStockManager</span><span class="o">.</span><span class="na">requestPriceUpdates</span><span class="o">(</span><span class="n">mListener</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onInactive</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mStockManager</span><span class="o">.</span><span class="na">removeUpdates</span><span class="o">(</span><span class="n">mListener</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>你可以在片段中使用它，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onActivityCreated</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StockLiveData</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getActivity</span><span class="o">()).</span><span class="na">observe</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">price</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// Update the UI.
</span><span class="c1"></span>        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>多个<code>fragment</code>和<code>activity</code>可以观察<code>MyPriceListener</code>实例。如果<code>LiveData</code>只有一个或多个可见并处于活动状态，则<code>LiveData</code>仅连接到系统服务。</p>
<h3 id="转换livedata">转换LiveData</h3>
<p>您可能希望在存储在<code>LiveData</code>对象中的值被更改为观察者之前，或者您可能需要基于另一个<code>LiveData</code>实例的值返回不同的<code>LiveData</code>实例。 <code>Lifecycle</code>软件包提供<code>Transformations</code>类，其中包括支持这些场景的帮助程序方法。</p>
<p><code>Transformations.map()</code></p>
<p>在存储在<code>LiveData</code>对象中的值上应用函数，并向下游传播结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LiveData</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">userLiveData</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">LiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">userName</span> <span class="o">=</span> <span class="n">Transformations</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">userLiveData</span><span class="o">,</span> <span class="n">user</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">user</span><span class="o">.</span><span class="na">name</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">lastName</span>
<span class="o">});</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Transformations.switchMap()</code></p>
<p>与<code>map()</code>类似，将函数应用于存储在<code>LiveData</code>对象中的值，并展开并向下游分派结果。传递给<code>switchMap()</code>的函数必须返回一个<code>LiveData</code>对象，如下例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">LiveData</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">getUser</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...;</span>
<span class="o">}</span>

<span class="n">LiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">userId</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">LiveData</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">Transformations</span><span class="o">.</span><span class="na">switchMap</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="n">getUser</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>您可以使用转换方法在观察者的生命周期中传递信息。除非观察者正在观看返回的<code>LiveData</code>对象，否则不会计算转换。由于转换是懒散计算的，因此与生命周期相关的行为会隐式传递，而不需要额外的显式调用或依赖关系。</p>
<p>如果您认为您需要<code>ViewModel</code>对象中的<code>Lifecycle</code>对象，则转换可能是更好的解决方案。例如，假设您有一个接受地址并返回该地址的邮政编码的UI组件。您可以为此组件实现朴素的ViewModel，如以下示例代码所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MyViewModel</span> <span class="kd">extends</span> <span class="n">ViewModel</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">PostalCodeRepository</span> <span class="n">repository</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyViewModel</span><span class="o">(</span><span class="n">PostalCodeRepository</span> <span class="n">repository</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">this</span><span class="o">.</span><span class="na">repository</span> <span class="o">=</span> <span class="n">repository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">LiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getPostalCode</span><span class="o">(</span><span class="n">String</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">// DON&#39;T DO THIS
</span><span class="c1"></span>       <span class="k">return</span> <span class="n">repository</span><span class="o">.</span><span class="na">getPostCode</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>UI组件随后需要从以前的<code>LiveData</code>对象注销，并在每次调用<code>getPostalCode()</code>时注册到新实例。另外，如果UI组件被重新创建，它会触发对<code>repository.getPostCode()</code>方法的另一次调用，而不是使用先前调用的结果。</p>
<p>相反，您可以将邮政编码查找实现为地址输入的转换，如以下示例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MyViewModel</span> <span class="kd">extends</span> <span class="n">ViewModel</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">PostalCodeRepository</span> <span class="n">repository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">MutableLiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">addressInput</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MutableLiveData</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">LiveData</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">postalCode</span> <span class="o">=</span>
            <span class="n">Transformations</span><span class="o">.</span><span class="na">switchMap</span><span class="o">(</span><span class="n">addressInput</span><span class="o">,</span> <span class="o">(</span><span class="n">address</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">repository</span><span class="o">.</span><span class="na">getPostCode</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
             <span class="o">});</span>

  <span class="kd">public</span> <span class="nf">MyViewModel</span><span class="o">(</span><span class="n">PostalCodeRepository</span> <span class="n">repository</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">repository</span> <span class="o">=</span> <span class="n">repository</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setInput</span><span class="o">(</span><span class="n">String</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">addressInput</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种情况下，邮政编码字段用<code>public</code>和<code>final</code>修饰，因为该字段永远不会改变。<code>postalCode</code>字段定义为<code>addressInput</code>的转换，这意味着<code>addressInput</code>发生更改时将调用<code>repository.getPostCode()</code>方法。如果存在活动观察者，那么这是真实的，如果在<code>repository.getPostCode()</code>被调用时没有活动观察者，则在添加观察者之前不进行计算。</p>
<p>该机制允许较低级别的应用程序创建按需延迟计算的<code>LiveData</code>对象。<code>ViewModel</code>对象可以轻松获得对<code>LiveData</code>对象的引用，然后在其上定义转换规则。</p>
<h4 id="创建新的transformations">创建新的transformations</h4>
<p>有十几种不同的特定转换可能在您的应用中很有用，但它们不是默认提供的。要实现自己的转换，您可以使用<code>MediatorLiveData</code>类，它监听其他<code>LiveData</code>对象并处理它们发出的事件。 <code>MediatorLiveData</code>将其状态正确传播到源<code>LiveData</code>对象。要了解有关此模式的更多信息，请参阅<code>Transformations</code>类的参考文档。</p>
<h3 id="合并多个livedata源">合并多个LiveData源</h3>
<p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，允许您合并多个<code>LiveData</code>源。 <code>MediatorLiveData</code>对象的观察者随后会在任何原始<code>LiveData</code>源对象更改时触发。</p>
<p>例如，如果您的UI中有一个可从本地数据库或网络更新的<code>LiveData</code>对象，则可以将以下源添加到<code>MediatorLiveData</code>对象：</p>
<p>与存储在数据库中的数据关联的<code>LiveData</code>对象。</p>
<p>与从网络访问的数据关联的<code>LiveData</code>对象。</p>
<p>您的<code>activity</code>只需观察<code>MediatorLiveData</code>对象即可从两个来源接收更新。有关详细示例，请参阅应用程序体系结构指南的附录：展示网络状态部分。</p>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">malinkang</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-05-18
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/navigation-implementing/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">实现navigation</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/goodbye-xiao-hua/">
            <span class="next-text nav-default">小花，再见</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'malinkang-cn';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/malinkang" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/malinkang" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/malinkang" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://malinkang.cn/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">malinkang</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>

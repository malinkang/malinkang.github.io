<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="《Java并发编程实战》第13章显式锁" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="在Java 5.0之前，在协调对共享对象的访问时可以使用的机制只有synchronized和volatile。Java5.0增加了一种新的机制：ReentrantLock。ReentrantLock并不是一种替代内置锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。" /><meta property="og:description" content="在Java 5.0之前，在协调对共享对象的访问时可以使用的机制只有synchronized和volatile。Java5.0增加了一种新的机制：ReentrantLock。ReentrantLock并不是一种替代内置锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。" /><link rel="canonical" href="https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/" /><meta property="og:url" content="https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/" /><meta property="og:site_name" content="malinkang" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2015-10-29T18:53:22+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="《Java并发编程实战》第13章显式锁" /><meta name="twitter:site" content="@malinkang" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"在Java 5.0之前，在协调对共享对象的访问时可以使用的机制只有synchronized和volatile。Java5.0增加了一种新的机制：ReentrantLock。ReentrantLock并不是一种替代内置锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。","headline":"《Java并发编程实战》第13章显式锁","dateModified":"2021-06-21T16:28:24+08:00","url":"https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/","datePublished":"2015-10-29T18:53:22+08:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/"},"@context":"https://schema.org"}</script><title>《Java并发编程实战》第13章显式锁 | malinkang</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="malinkang"><meta name="application-name" content="malinkang"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://malinkang-1253444926.cos.ap-beijing.myqcloud.com/images/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">malinkang</a></div><div class="site-subtitle font-italic">人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/malinkang" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/malinkang" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['linkang.ma','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>《Java并发编程实战》第13章显式锁</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>《Java并发编程实战》第13章显式锁</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> malinkang </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Oct 29, 2015, 6:53 PM +0800" prep="on" > Oct 29, 2015 <i class="unloaded">2015-10-29T18:53:22+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jun 21, 2021, 4:28 PM +0800" prefix="Updated " > Jun 21 <i class="unloaded">2021-06-21T16:28:24+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3140 words">17 min</span></div></div><div class="post-content"><p>在<code class="language-plaintext highlighter-rouge">Java 5.0</code>之前，在协调对共享对象的访问时可以使用的机制只有<code class="language-plaintext highlighter-rouge">synchronized</code>和<code class="language-plaintext highlighter-rouge">volatile</code>。Java5.0增加了一种新的机制：<code class="language-plaintext highlighter-rouge">ReentrantLock</code>。<code class="language-plaintext highlighter-rouge">ReentrantLock</code>并不是一种替代内置锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://malinkang-1253444926.cos.ap-beijing.myqcloud.com/blog/images/ReentrantLock.png" alt="ReentrantLock" /></p><h2 id="131-lock与reentrantlock">13.1 Lock与ReentrantLock</h2><p><code class="language-plaintext highlighter-rouge">Lock</code>接口中定义了一组抽象的加锁操作。与内置加锁机制不同的是，<code class="language-plaintext highlighter-rouge">Lock</code>提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的。在<code class="language-plaintext highlighter-rouge">Lock</code>的实现中必须提供与内部锁相同的内存可见性语义，但在加锁语义、调度算法、顺序保证以及性能特性等方面可以有所不同。</p><p><code class="language-plaintext highlighter-rouge">ReentrantLock</code>实现了<code class="language-plaintext highlighter-rouge">Lock</code>接口，并提供了与<code class="language-plaintext highlighter-rouge">synchronized</code>相同的互斥性和内存可见性。在获取<code class="language-plaintext highlighter-rouge">ReentrantLock</code>时，有着与进入同步代码块相同的内存语义，在释放<code class="language-plaintext highlighter-rouge">ReentrantLock</code>时，同样有着与退出同步代码块相同的内存语义。此外，与<code class="language-plaintext highlighter-rouge">synchronized</code>一样，<code class="language-plaintext highlighter-rouge">ReentrantLock</code>还提供了可重入的加锁语义。<code class="language-plaintext highlighter-rouge">ReentrantLock</code>支持在<code class="language-plaintext highlighter-rouge">Lock</code>接口中定义的所有获取锁模式，并且与<code class="language-plaintext highlighter-rouge">synchronized</code>相比，它还为处理锁的不可用性问题提供了更高的灵活性。</p><p>为什么要创建一种与内置锁如此相似的新加锁机制？在大多数情况下，内置锁都能很好地工作，但在功能上存在一些局限性，例如，无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限地等待下去。内置锁必须在获取该锁的代码块中释放，这就简化了编码工作，并且与异常处理操作实现了很好的交互，但却无法实现非阻塞结构的加锁规则。这些都是使用<code class="language-plaintext highlighter-rouge">synchronized</code>的原因，但在某些情况下，一种更灵活的加锁机制通常能提供更好的灵活性或性能。</p><p>Lock接口的标准使用形式比使用内置锁复杂一些：必须在<code class="language-plaintext highlighter-rouge">finally</code>块中释放锁。否则，如果在被保护的代码中抛出了异常，那么这个锁永远都无法释放。当使用加锁时，还必须考虑在try块中抛出异常的情况，如果可能使对象处于某种不一致的状态，那么就需要更多的try-catch或try-finally代码块。</p><p>如果没有使用finally来释放Lock，那么相当于启动了一个定时炸弹。当“炸弹爆炸”时，将很难追踪到最初发生错误的位置，因为没有记录应该释放锁的位置和时间。这就是<code class="language-plaintext highlighter-rouge">ReentrantLock</code>不能完全替代<code class="language-plaintext highlighter-rouge">synchronized</code>的原因：它更加“危险”，因为当程序的执行控制离开被保护的代码块时，不会自动清除锁。虽然在<code class="language-plaintext highlighter-rouge">finally</code>块中释放锁并不困难，但也可能忘记。</p><h3 id="1311-轮询锁与定时锁">13.1.1 轮询锁与定时锁</h3><h3 id="1312-可中断的锁获取操作">13.1.2 可中断的锁获取操作</h3><h3 id="1313-非块结构的加锁">13.1.3 非块结构的加锁</h3><h2 id="132-性能考虑因素">13.2 性能考虑因素</h2><h2 id="133-公平性">13.3 公平性</h2><p>在<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的构造函数中提供了两种公平性选择：创建一个非公平的锁或者一个公平的锁。在公平的锁上，线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”：当一个线程请求非公平的锁时，如果再发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。非公平的<code class="language-plaintext highlighter-rouge">ReentrantLock</code>并不提倡“插队”行为，但无法防止某个线程在合适的时候进行“插队”。在公平锁中，如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将被放入队列中。在非公平锁的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。</p><p>我们为什么不希望所有的锁都是公平的？毕竟，公平是一种好的行为，而不公平则是一种不好的行为。当执行加锁操作时，公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。在大多数情况下，非公平锁的性能要高于公平锁的性能。</p><h2 id="134-在synchronized和reentrantlock之间进行选择">13.4 在synchronized和ReentrantLock之间进行选择</h2><p><code class="language-plaintext highlighter-rouge">ReentrantLock</code>在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。<code class="language-plaintext highlighter-rouge">ReentrantLock</code>在性能上似乎优于内置锁，其中在Java 6中略有胜出，而在Java 5.0中则是远远胜出。</p><p>与显式锁相比，内置锁仍然具有很大的优势。内置锁为许多开发人员所熟悉，并且简洁紧凑。<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的危险性比同步机制更高，如果忘记在finally块中调用<code class="language-plaintext highlighter-rouge">unlock</code>，那么虽然代码表面上能正常运行，但实际上已经埋下了一颗定时炸弹，并很有可能伤及其他代码。仅当内置锁不能满足需求时，才可以考虑使用<code class="language-plaintext highlighter-rouge">ReentrantLock</code>。</p><p>在Java 5.0中，内置锁与<code class="language-plaintext highlighter-rouge">ReentrantLock</code>相比还有另一个优点：在线程转储中能给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的线程。JVM并不知道哪些线程持有<code class="language-plaintext highlighter-rouge">ReentrantLock</code>，因此在调试使用<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的线程的问题时，将起不到帮助作用。Java6解决了这个问题，它提供了一个管理和调试接口，锁可以通过该接口进行注册，从而与<code class="language-plaintext highlighter-rouge">ReentrantLock</code>相关的加锁信息就能出现在线程转储中，并通过其他的管理接口和调试接口来访问。与<code class="language-plaintext highlighter-rouge">synchronized</code>相比，这些调试消息是一种重要的优势，即便它们大部分都是临时性消息，线程转储中的加锁能给很多程序员带来帮助。<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的非块结构特性仍然意味着，获取锁的操作不能与特定的栈帧关联起来，而内置锁可以。</p><p>未来更可能会提升<code class="language-plaintext highlighter-rouge">synchronized</code>而不是<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的性能。因为<code class="language-plaintext highlighter-rouge">synchronized</code>是JVM的内置属性，它能执行一些优化，例如对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置锁的同步，而如果通过基于类库的锁来实现这些功能，则可能性不大。除非将来需要在Java 5.0上部署应用程序，并且在该平台上确实需要<code class="language-plaintext highlighter-rouge">ReentrantLock</code>包含的可伸缩性，否则就性能方面来说，应该选择<code class="language-plaintext highlighter-rouge">synchronized</code>而不是<code class="language-plaintext highlighter-rouge">ReentrantLock</code>。</p><h2 id="135-读写锁">13.5 读写锁</h2><p><code class="language-plaintext highlighter-rouge">ReentrantLock</code>实现了一种标准的互斥锁：每次最多只有一个线程持有<code class="language-plaintext highlighter-rouge">ReentrantLock</code>。但对于维护数据的完成性来说，互斥通常是一种过于强硬的加锁规则，因此也就不必要地限制了并发性。互斥是一种保守的加锁策略，虽然可以避免“写/写”冲突和“写/读”冲突，但同样也避免了“读/读”冲突。在许多情况下，数据结构上的操作都是“读操作”，虽然它们也是可变的并且在某些情况下被修改，但其中大多数访问操作都是读操作。此时，如果能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。只要每个线程都能确保读取到最新的数据，并且在读取数据时不会有其他的线程修改数据，那么就不会发生问题。在这种情况下就可以使用读/写锁：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。</p><p><code class="language-plaintext highlighter-rouge">ReadWriteLock</code>中暴露了两个Lock对象，其中一个用于读操作，而另一个用于写操作。要读取由<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>保护的数据，必须首先获得读取锁，当需要修改<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>保护的数据时，必须首先获得写入锁。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ReadWriteLock</span><span class="o">{</span>
  <span class="nc">Lock</span> <span class="nf">readLock</span><span class="o">();</span>
  <span class="nc">Lock</span> <span class="nf">writeLock</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在读写锁实现的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。与Lock一样，ReadWriteLock可以采用多种不同的实现方式，这些方式在性能、调度保证、获取优先性、公平性以及加锁语义等方面可能有所不同。</p><p>在读取锁和写入锁之间的交互可以采用多种实现方式。<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>中的一些可选操作包括：</p><ul><li><strong>释放优先</strong>。当一个写入操作释放写入锁时，并且队列中同时存在读线程和写线程，那么应该优先选择读线程，写线程，还是最先发出请求的线程。<li><strong>读线程插队</strong>。如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该再写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但却可能造成写线程发生饥饿问题。<li><strong>重入性</strong>。读取锁和写入所是否可重入？<li><strong>降级</strong>。如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读取锁？这可能会使得写入锁被“降级”为读取锁，同时不允许其他写线程修改被保护的资源。<li><strong>升级</strong>。读取锁能否优先于其他正在等待的读线程和写线程而升级为一个写入锁？在大多数的读-写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。</ul><p><code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>为这两种锁都提供了可重入的加锁语义。与<code class="language-plaintext highlighter-rouge">ReentrantLock</code>类似，<code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>在构造时也可以是一个非公平的锁（默认）还是一个公平的锁。在公平的锁中，等待时间最长的线程将优先获取锁。如果这个锁由读线程持有，而另一个线程请求写入锁，那么其他读线程都不能获得读取锁，直到写线程使用完并且释放了写入锁。在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程时可以的，但从读线程升级为写线程则是不可以的。</p><p>与<code class="language-plaintext highlighter-rouge">ReentrantLock</code>类似的是，<code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>中的写入锁只能有唯一的所有者，并且只能由获得该锁的线程来释放。在Java5.0中，读取锁的行为更类似于<code class="language-plaintext highlighter-rouge">Semaphore</code>而不是锁，它只维护活跃的读线程的数量，而不考虑它们的标识。在Java6中修改了这个行为：记录哪些线程已经获得了读者锁。</p><p>当锁的持有时间较长并且大部分操作都不会修改被守护的资源时，那么读-写锁能提高并发性。</p><h2 id="参考">参考</h2><ul><li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" class="post-tag no-text-decoration" >Java并发编程实战</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=《Java并发编程实战》第13章显式锁 - malinkang&url=https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=《Java并发编程实战》第13章显式锁 - malinkang&u=https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=《Java并发编程实战》第13章显式锁 - malinkang&url=https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/dagger-guide/">Dagger使用指南</a><li><a href="/posts/understanding-the-jvm-runtime-data-areas/">《深入理解JVM》第2章Java内存区域与内存溢出异常</a><li><a href="/posts/understanding-the-jvm-garbage-collection/">《深入理解JVM》第3章垃圾收集器</a><li><a href="/posts/understanding-the-jvm-class-file-structure/">《深入理解JVM》第6章类文件结构</a><li><a href="/posts/understanding-the-jvm-class-loader/">《深入理解JVM》第7章虚拟机类加载机制</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a> <a class="post-tag" href="/tags/thinking-in-java/">Thinking in Java</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/kotlin/">Kotlin</a> <a class="post-tag" href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a> <a class="post-tag" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/">深入理解JVM</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/databinding/">databinding</a> <a class="post-tag" href="/tags/recyclerview/">RecyclerView</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-currency-in-practice-thread-safety/"><div class="card-body"> <span class="timeago small" > Sep 24, 2015 <i class="unloaded">2015-09-24T18:53:22+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Java并发编程实战》第2章线程安全性</h3><div class="text-muted small"><p> 一个对象是否需要是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要使得对象时线程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。 当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字sy...</p></div></div></a></div><div class="card"> <a href="/posts/java-currency-in-practice-sharing-objects/"><div class="card-body"> <span class="timeago small" > Oct 1, 2015 <i class="unloaded">2015-10-01T18:53:22+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Java并发编程实战》第3章对象的共享</h3><div class="text-muted small"><p> 我们已经知道了同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字synchronized只能用于实现原子性或者确定临界区。同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。如果没有同步，那么这种情...</p></div></div></a></div><div class="card"> <a href="/posts/java-currency-in-practice-building-blocks/"><div class="card-body"> <span class="timeago small" > Oct 8, 2015 <i class="unloaded">2015-10-08T18:53:22+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>《Java并发编程实战》第5章基础构建模块</h3><div class="text-muted small"><p> Java平台类库包含了丰富的并发基础构建模块，例如线程安全的容器类以及各种用于协调多个相互协作的线程控制流的同步工具类（Synchronizer）。本章将介绍其中一些最有用的开发构建模块，特别是在Java5.0和Java6中引入的一些新模块，以及在使用这些模块来构造并发应用程序时的一些常用模式。 5.1 同步容器类 同步容器类包括Vector和Hashtable，二者都是早期JDK的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-currency-in-practice-applying-thread-pools/" class="btn btn-outline-primary" prompt="Older"><p>《Java并发编程实战》第8章线程池的使用</p></a> <a href="/posts/java-currency-in-practice-building-custom-synchronizers/" class="btn btn-outline-primary" prompt="Newer"><p>《Java并发编程实战》第14章构建自定义的同步工具</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//malinkang-cn.disqus.com/embed.js', disqusConfig: function() { this.page.title = '《Java并发编程实战》第13章显式锁'; this.page.url = 'https://malinkang.cn/posts/java-currency-in-practice-explicit-locks/'; this.page.identifier = '/posts/java-currency-in-practice-explicit-locks/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/malinkang">malinkang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a> <a class="post-tag" href="/tags/thinking-in-java/">Thinking in Java</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/kotlin/">Kotlin</a> <a class="post-tag" href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a> <a class="post-tag" href="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/">深入理解JVM</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/databinding/">databinding</a> <a class="post-tag" href="/tags/recyclerview/">RecyclerView</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://malinkang.cn{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>

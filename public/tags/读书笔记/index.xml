<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>读书笔记 on 人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</title>
    <link>https://malinkang.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 读书笔记 on 人生最可悲的事情，莫过于胸怀大志，却又虚度光阴。</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 05 Jan 2020 15:52:23 +0000</lastBuildDate>
    
	<atom:link href="https://malinkang.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Epoxy Models</title>
      <link>https://malinkang.cn/post/epoxy-models/</link>
      <pubDate>Sun, 05 Jan 2020 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/epoxy-models/</guid>
      <description>概览（Overview） Epoxy uses EpoxyModel objects to decide which views to display and how to bind data to them. This is similar to the popular ViewModel pattern. Models also allow you to control other aspects of the view, such as the grid span size, id, and saved state. Epoxy使用Epoxy</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第8章 通用程序设计</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter8/</link>
      <pubDate>Thu, 28 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter8/</guid>
      <description>第45条：将局部变量的作用域最小化 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。 循环中提供了特殊的机会来将变量的作用</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第8章 通用程序设计</title>
      <link>https://malinkang.cn/post/effective-java-chapter8/</link>
      <pubDate>Thu, 28 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter8/</guid>
      <description>第45条：将局部变量的作用域最小化 要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。 循环中提供了特殊的机会来将变量的作用</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第7章 方法</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter7/</link>
      <pubDate>Wed, 20 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter7/</guid>
      <description>第38条：检查参数的有效性 对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值会抛出的异常。一旦在文档中记录了对于方</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第7章 方法</title>
      <link>https://malinkang.cn/post/effective-java-chapter7/</link>
      <pubDate>Wed, 20 Feb 2019 14:19:41 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter7/</guid>
      <description>第38条：检查参数的有效性 对于公有的方法，要用Javadoc的@throws标签在文档中说明违反参数值会抛出的异常。一旦在文档中记录了对于方</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第6章 枚举和注解</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter6/</link>
      <pubDate>Mon, 18 Feb 2019 09:58:30 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter6/</guid>
      <description>第30条：用enum代替int常量 在编程语言中还没有引入枚举类型之前，表示枚举类型的常量模式是声明一组具名的int常量，每个类型成员一个常量</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第6章 枚举和注解</title>
      <link>https://malinkang.cn/post/effective-java-chapter6/</link>
      <pubDate>Mon, 18 Feb 2019 09:58:30 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter6/</guid>
      <description>第30条：用enum代替int常量 在编程语言中还没有引入枚举类型之前，表示枚举类型的常量模式是声明一组具名的int常量，每个类型成员一个常量</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第5章 泛型</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter5/</link>
      <pubDate>Sat, 16 Feb 2019 16:20:11 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter5/</guid>
      <description>第23条：请不要在新代码中使用原生态类型 声明中具有一个或者多个类型参数（type parameter）的类或者接口就是泛型类或者接口。泛型类和</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第5章 泛型</title>
      <link>https://malinkang.cn/post/effective-java-chapter5/</link>
      <pubDate>Sat, 16 Feb 2019 16:20:11 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter5/</guid>
      <description>第23条：请不要在新代码中使用原生态类型 声明中具有一个或者多个类型参数（type parameter）的类或者接口就是泛型类或者接口。泛型类和</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第4章 类和接口</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter4/</link>
      <pubDate>Fri, 15 Feb 2019 16:25:04 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter4/</guid>
      <description>第13条：使类和成员的可访问性最小化 Java程序设计语言提供了许多机制来协助信息隐藏。访问控制（access control)机制决定了类、接</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第4章 类和接口</title>
      <link>https://malinkang.cn/post/effective-java-chapter4/</link>
      <pubDate>Fri, 15 Feb 2019 16:25:04 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter4/</guid>
      <description>第13条：使类和成员的可访问性最小化 Java程序设计语言提供了许多机制来协助信息隐藏。访问控制（access control)机制决定了类、接</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第3章 对于所有对象都通用的方法</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter3/</link>
      <pubDate>Tue, 12 Feb 2019 09:54:13 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter3/</guid>
      <description>第8条：覆盖equals时请遵守通用约定 在覆盖equals方法的时候，你必须要遵守它的通用约定。 自反性（reflexive）。对于任何非nu</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第3章 对于所有对象都通用的方法</title>
      <link>https://malinkang.cn/post/effective-java-chapter3/</link>
      <pubDate>Tue, 12 Feb 2019 09:54:13 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter3/</guid>
      <description>第8条：覆盖equals时请遵守通用约定 在覆盖equals方法的时候，你必须要遵守它的通用约定。 自反性（reflexive）。对于任何非nu</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第2章 创建和销毁对象</title>
      <link>https://malinkang.cn/effective-java/effective-java-chapter2/</link>
      <pubDate>Sat, 05 Jan 2019 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/effective-java/effective-java-chapter2/</guid>
      <description>《Effective Java》经常出现在各个Java推荐书单里，自己也曾买过一本看了几章，便被束之高阁。最近发现第三版也已经出版了。所以把读</description>
    </item>
    
    <item>
      <title>《Effective Java》读书笔记 第2章 创建和销毁对象</title>
      <link>https://malinkang.cn/post/effective-java-chapter2/</link>
      <pubDate>Sat, 05 Jan 2019 15:52:23 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/effective-java-chapter2/</guid>
      <description>《Effective Java》经常出现在各个Java推荐书单里，自己也曾买过一本看了几章，便被束之高阁。最近发现第三版也已经出版了。所以把读</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第8章 Lambda作为形参和返回值</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter8/</link>
      <pubDate>Wed, 12 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter8/</guid>
      <description>8.1 声明高阶函数 高阶函数就是以另一个函数作为参数或者返回值的函数。 8.1.1 函数类型 1 2 3 4 5 6 7 8 val sum = { x: Int, y: Int -&amp;gt; x + y } val action = { println(42)} run { println(sum(1,2)) //3 } run{ action()</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第7章 运算符重载及其他约定</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter7/</link>
      <pubDate>Sun, 09 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter7/</guid>
      <description>7.1 重载算术运算符 7.1.1 重载二元算术运算 1 2 3 4 5 6 7 8 data class Point(val x: Int, val y: Int) { operator fun plus(other: Point): Point { return Point(x + other.x, y + other.y) } } val p1 = Point(10, 20) val p2 = Point(30, 40) println(p1 + p2) //Point(x=40, y=60) {% code-tabs %} {% code-tabs-item t</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第6章 Kotlin的类型系统</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter6/</link>
      <pubDate>Thu, 06 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter6/</guid>
      <description>6.1 可空性 6.1.1 可空类型 1 2 //增加了null检查后，这段代码就可以编译了 fun strLenSafe(s: String?) = if (s != null) s.length else 0 6.1.2 类型的含义 6.1.3 安全调用运算符 安全调用运算符?允许把</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第5章 Lambda编程</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter5/</link>
      <pubDate>Tue, 04 Sep 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter5/</guid>
      <description>5.1 Lambda表达式和成员引用 5.1.1 Lambda简介：作为函数参数的代码块 1 2 3 4 5 6 button.setOnClickLisener(new OnClickListener(){ @Override public void onClick(View view){ //点击后执行的动作 } } 1 button.se</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第4章 类对象和接口</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter4/</link>
      <pubDate>Tue, 28 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter4/</guid>
      <description>4.1 定义类继承结构 4.1.1 Kotlin中的接口 1 2 3 4 5 6 7 8 //接口定义 interface Clickable { fun click() } //实现接口 class Button:Clickable{ override fun click() = println(&amp;#34;I was clicked&amp;#34;) } 接口的方法可以有一个默认实现。</description>
    </item>
    
    <item>
      <title>《Kotlin实战》读书笔记 第3章 函数的定义与调用</title>
      <link>https://malinkang.cn/post/kotlin-in-action-chapter3/</link>
      <pubDate>Sat, 25 Aug 2018 12:26:55 +0000</pubDate>
      
      <guid>https://malinkang.cn/post/kotlin-in-action-chapter3/</guid>
      <description>3.1 在kotlin中创建集合 1 2 3 4 5 6 7 val set = hashSetOf(1, 7, 53) val list = arrayListOf(1, 7, 53) val map = hashMapOf(1 to &amp;#34;one&amp;#34;, 7 to &amp;#34;seven&amp;#34;, 53 to &amp;#34;fifty-three&amp;#34;) //kotlin的javaClass等价于Java的</description>
    </item>
    
  </channel>
</rss>